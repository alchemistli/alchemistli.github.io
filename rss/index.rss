<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Alchemist's Crafts</title><description>Thoughts, stories and ideas.</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Sat, 02 Jan 2016 06:29:42 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Trello有趣的apply job题目</title><description>&lt;p&gt;Trello果然很有趣，申请程序job的话，首先要做一道题目。&lt;/p&gt;

&lt;p&gt;题目是这样的&lt;/p&gt;

&lt;!--more--&gt;  

&lt;p&gt;Write code to find a 8 letter string of characters that contains only letters from&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acdegilmnoprstuw&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;such that the hash(the_string) is&lt;/p&gt;

&lt;p&gt;&lt;code&gt;25377615533200&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;if hash is defined by the following pseudo-code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Int64 hash (String s) {  
    Int64 h = 7
    String letters = "acdegilmnoprstuw"
    for(Int32 i = 0;&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/trelloyou-qu-de-apply-jobti-mu/</link><guid isPermaLink="false">3e226be9-004c-4259-913f-573918b3ecf3</guid><category>Swift</category><dc:creator>Alchemist Li</dc:creator><pubDate>Sat, 02 Jan 2016 06:25:19 GMT</pubDate><content:encoded>&lt;p&gt;Trello果然很有趣，申请程序job的话，首先要做一道题目。&lt;/p&gt;

&lt;p&gt;题目是这样的&lt;/p&gt;

&lt;!--more--&gt;  

&lt;p&gt;Write code to find a 8 letter string of characters that contains only letters from&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acdegilmnoprstuw&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;such that the hash(the_string) is&lt;/p&gt;

&lt;p&gt;&lt;code&gt;25377615533200&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;if hash is defined by the following pseudo-code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Int64 hash (String s) {  
    Int64 h = 7
    String letters = "acdegilmnoprstuw"
    for(Int32 i = 0; i &amp;lt; s.length; i++) {
        h = (h * 37 + letters.indexOf(s[i]))
    }
    return h
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, if we were trying to find the 7 letter string where hash(the_string) was 680131659347, the answer would be "leepadg".&lt;/p&gt;

&lt;p&gt;我在playground里写了一个解法，答案是&lt;code&gt;nsanswer&lt;/code&gt;&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/ff5d642c18fa99caec48.js"&gt;&lt;/script&gt;</content:encoded></item><item><title>在CAShapeLayer上动画的画出CGPath</title><description>&lt;p&gt;CAShapeLayer上有两个好玩的属性叫做&lt;code&gt;strokeStart&lt;/code&gt;和&lt;code&gt;strokeEnd&lt;/code&gt;。使用这两个属性可以作出非常有意思的动画&lt;/p&gt;

&lt;!--more--&gt;  

&lt;p&gt;可以先看一下demo先感受一下&lt;/p&gt;

&lt;video controls&gt;  
&lt;source src="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4" type="video/mp4"&gt;  
&lt;/video&gt;

&lt;p&gt;&lt;/p&gt;  

&lt;p&gt;&lt;code&gt;strokeStart&lt;/code&gt;和&lt;code&gt;strokeEnd&lt;/code&gt;的取值范围都是0.0到1.0。含义分别是path开始绘制的地方和结束绘制的地方。它们的默认值分别是0.0和1.0。如果你只想path画前一半的话，那只要设置&lt;code&gt;strokeEnd = 0.5&lt;/code&gt;，这样，渲染的时候就只会画一半了。&lt;/p&gt;

&lt;p&gt;最重要的是－－这两个属性是可以有动画效果的，可以看到上面的效果&lt;/p&gt;

&lt;p&gt;核心代码如下&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/ea47e7983e64a8edd20b.js"&gt;&lt;/script&gt;

&lt;p&gt;这种效果还可以使用在字符上面，不过前提是我们需要把字符的图形转换成CGPath。&lt;/p&gt;

&lt;p&gt;可以看一下下面的demo&lt;/p&gt;

&lt;video controls&gt;  
&lt;source src="http://oleb.net/media/AnimatedPathsHelloWorld.mp4" type="video/mp4"&gt;  
&lt;/video&gt;  

&lt;p&gt;&lt;/p&gt;

&lt;h3 id="swiftcfarray"&gt;swift中使用CFArray&lt;/h3&gt;

&lt;p&gt;从字符转化成路径的时候碰到点小问题，使用&lt;code&gt;CTLineGetGlyphRuns&lt;/code&gt;时，必须要和CFArray打交道。因为它会返回一个放置了CTRun的CFArray。这里有几种办法来解决，这里介绍两种比较好的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CFArray转换成Array&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let runArray = ((CTLineGetGlyphRuns(line) as [AnyObject]) as! [CTRunRef])  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;另外一种是把CFArray里的void指针强转成swift可以识别的类型，使用&lt;code&gt;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>http://localhost:2368/zai-cashapelayershang-dong-hua-de-hua-chu-cgpath/</link><guid isPermaLink="false">222e2118-a08c-4087-a6c7-4a546992d69b</guid><dc:creator>Alchemist Li</dc:creator><pubDate>Mon, 28 Dec 2015 09:39:42 GMT</pubDate><content:encoded>&lt;p&gt;CAShapeLayer上有两个好玩的属性叫做&lt;code&gt;strokeStart&lt;/code&gt;和&lt;code&gt;strokeEnd&lt;/code&gt;。使用这两个属性可以作出非常有意思的动画&lt;/p&gt;

&lt;!--more--&gt;  

&lt;p&gt;可以先看一下demo先感受一下&lt;/p&gt;

&lt;video controls&gt;  
&lt;source src="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4" type="video/mp4"&gt;  
&lt;/video&gt;

&lt;p&gt;&lt;/p&gt;  

&lt;p&gt;&lt;code&gt;strokeStart&lt;/code&gt;和&lt;code&gt;strokeEnd&lt;/code&gt;的取值范围都是0.0到1.0。含义分别是path开始绘制的地方和结束绘制的地方。它们的默认值分别是0.0和1.0。如果你只想path画前一半的话，那只要设置&lt;code&gt;strokeEnd = 0.5&lt;/code&gt;，这样，渲染的时候就只会画一半了。&lt;/p&gt;

&lt;p&gt;最重要的是－－这两个属性是可以有动画效果的，可以看到上面的效果&lt;/p&gt;

&lt;p&gt;核心代码如下&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/ea47e7983e64a8edd20b.js"&gt;&lt;/script&gt;

&lt;p&gt;这种效果还可以使用在字符上面，不过前提是我们需要把字符的图形转换成CGPath。&lt;/p&gt;

&lt;p&gt;可以看一下下面的demo&lt;/p&gt;

&lt;video controls&gt;  
&lt;source src="http://oleb.net/media/AnimatedPathsHelloWorld.mp4" type="video/mp4"&gt;  
&lt;/video&gt;  

&lt;p&gt;&lt;/p&gt;

&lt;h3 id="swiftcfarray"&gt;swift中使用CFArray&lt;/h3&gt;

&lt;p&gt;从字符转化成路径的时候碰到点小问题，使用&lt;code&gt;CTLineGetGlyphRuns&lt;/code&gt;时，必须要和CFArray打交道。因为它会返回一个放置了CTRun的CFArray。这里有几种办法来解决，这里介绍两种比较好的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CFArray转换成Array&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let runArray = ((CTLineGetGlyphRuns(line) as [AnyObject]) as! [CTRunRef])  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;另外一种是把CFArray里的void指针强转成swift可以识别的类型，使用&lt;code&gt;unsafeBitCast&lt;/code&gt;(其实就是老的reinterpret)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;let arr = NSArray(object: "meow")  
let str = unsafeBitCast(CFArrayGetValueAtIndex(arr, 0), CFString.self)  
// str = "meow"
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="swift"&gt;swift源代码&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/IamAlchemist/AnimatedPath"&gt;AnimatedPath&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=""&gt;参考&lt;/h5&gt;

&lt;p&gt;&lt;a href="http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer/"&gt;Animating the Drawing of a CGPath With CAShapeLayer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://swifter.tips/unsafe/"&gt;UNSAFEPOINTER&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://zonble.net/archives/2015_03/1668.php"&gt;在 Swift 裡頭呼叫 CFArray&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>Git 简介</title><description>&lt;p&gt;这里主要介绍给初次git命令行使用者在开发中常见的命令&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id="git"&gt;Git 特点&lt;/h3&gt;

&lt;p&gt;Git的主要的3个特点&lt;/p&gt;

&lt;h4 id="1git"&gt;1. Git直接记录快照，而非差异比较。&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;svn
&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png" alt=""&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png" alt=""&gt;&lt;/p&gt;

&lt;h4 id="2"&gt;2. 近乎所有操作都是本地执行&lt;/h4&gt;

&lt;p&gt;第一比较快；第二没有网络也可以工作；第三你只要不执行push，你是不会影响远程代码库的，所以在push之前，你影响的只是你自己；&lt;/p&gt;

&lt;h4 id="3git"&gt;3. Git 一般只添加数据&lt;/h4&gt;

&lt;p&gt;这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 
虽然最终一般情况下可以恢复，但是往往会花很多时间，这只是在最坏情况下，git比svn，perforce强的地方。所以不建议随便尝试，搞清楚命令是什么意思再执行&lt;/p&gt;

&lt;h3 id="git"&gt;Git的三种状态&lt;/h3&gt;

&lt;p&gt;Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 &lt;br&gt;
已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/areas.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="git"&gt;基本的 Git 工作流程如下：&lt;/h3&gt;</description><link>http://localhost:2368/git-jian-jie/</link><guid isPermaLink="false">eeadb6f9-9cbc-4f2d-997e-1f80a6328931</guid><category>Git</category><category>Knowledge</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 16 Dec 2015 01:24:44 GMT</pubDate><content:encoded>&lt;p&gt;这里主要介绍给初次git命令行使用者在开发中常见的命令&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id="git"&gt;Git 特点&lt;/h3&gt;

&lt;p&gt;Git的主要的3个特点&lt;/p&gt;

&lt;h4 id="1git"&gt;1. Git直接记录快照，而非差异比较。&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;svn
&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png" alt=""&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png" alt=""&gt;&lt;/p&gt;

&lt;h4 id="2"&gt;2. 近乎所有操作都是本地执行&lt;/h4&gt;

&lt;p&gt;第一比较快；第二没有网络也可以工作；第三你只要不执行push，你是不会影响远程代码库的，所以在push之前，你影响的只是你自己；&lt;/p&gt;

&lt;h4 id="3git"&gt;3. Git 一般只添加数据&lt;/h4&gt;

&lt;p&gt;这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 
虽然最终一般情况下可以恢复，但是往往会花很多时间，这只是在最坏情况下，git比svn，perforce强的地方。所以不建议随便尝试，搞清楚命令是什么意思再执行&lt;/p&gt;

&lt;h3 id="git"&gt;Git的三种状态&lt;/h3&gt;

&lt;p&gt;Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 &lt;br&gt;
已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
&lt;img src="https://git-scm.com/book/en/v2/book/01-introduction/images/areas.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="git"&gt;基本的 Git 工作流程如下：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在工作目录中修改文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暂存文件，将文件的快照放入暂存区域。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="git"&gt;Git 命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git clone -b&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;$ git clone -b web_63 https://github.com/libgit2/libgit2 mylibgit&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git status&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git add&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;untracked ＋ modified  －－－&gt; staged&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git checkout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;modified --(git checkout) --&gt; unmodified&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;staged --&gt; modified or untracked&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git diff&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看modified文件， git diff &lt;br&gt;
查看staged文件，git diff --staged  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git rm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除已跟踪的unstaged文件  git rm &lt;br&gt;
移除已跟踪的staged文件  git rm -f &lt;br&gt;
仅仅移除跟踪，但是保留本地文件 git rm --cached  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git fetch vs git pull&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;git pull = git fetch + git merge&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：&lt;/p&gt;

&lt;p&gt;显示详细更改 git log -p -2 &lt;br&gt;
显示更改统计 git log --stat －2 &lt;br&gt;
格式化显示 git log --pretty=oneline &lt;br&gt;
文艺范显示 git log --pretty=format:"%h - %an, %ar : %s" &lt;br&gt;
专家级显示 git log --pretty=format:"%h %s" --graph &lt;br&gt;
按作者过滤 git log --author=gitster &lt;/p&gt;

&lt;h3 id="gitbranch"&gt;Git branch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 3-1. 首次提交对象及其树结构 &lt;br&gt;
&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/commit-and-tree.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Figure 3-2. 提交对象及其父对象 &lt;br&gt;
&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/commits-and-parents.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/branch-and-history.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分支创建&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/two-branches.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前分支&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/head-to-master.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new  
34ac2 fixed bug #1328 - stack overflow under certain conditions  
98ca9 initial commit of my project  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;分支切换&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样 HEAD 就指向 testing 分支了。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://git-scm.com/book/en/v2/book/03-git-branching/images/advance-testing.png" alt=""&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;分支切换会改变你工作目录中的文件&lt;/strong&gt;&lt;/p&gt;
  
  &lt;p&gt;在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;查看分支图&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;合并分支&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c  
Fast-forward  
 index.html | 2 ++
 1 file changed, 2 insertions(+)
### More Deep for Git command
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;删除分支&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d hotfix
Deleted branch hotfix (3a0874c).  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=""&gt;遇到冲突时的分支合并&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git status
On branch master  
You have unmerged paths.  
  (fix conflicts and run "git commit")

Unmerged paths:  
  (use "git add &amp;lt;file&amp;gt;..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html  
&amp;lt;div id="footer"&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;  
=======
&amp;lt;div id="footer"&amp;gt;  
 please contact us at support@github.com
&amp;lt;/div&amp;gt;  
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53:index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add  
git commit  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;常用操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/basic-usage.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/basic-usage-2.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;图例说明&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/conventions.svg" alt=""&gt;&lt;/p&gt;

&lt;h3 id=""&gt;详解&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;commit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/commit-master.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/commit-maint.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/commit-amend.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checkout
checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/checkout-files.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/checkout-branch.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像master~3类似的东西，就得到一个匿名分支，称作detached HEAD（被分离的HEAD标识）。这样可以很方便地在历史版本之间互相切换。
&lt;img src="https://marklodato.github.io/visual-git-guide/checkout-detached.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;当HEAD处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)
&lt;img src="https://marklodato.github.io/visual-git-guide/commit-detached.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;一旦此后你切换到别的分支，比如说master，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用2eecb。
&lt;img src="https://marklodato.github.io/visual-git-guide/checkout-after-detached.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;但是，如果你想保存这个状态，可以用命令git checkout -b name来创建一个新的分支。
&lt;img src="https://marklodato.github.io/visual-git-guide/checkout-b-detached.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。&lt;/p&gt;

&lt;p&gt;如果不给选项，那么当前分支指向到那个提交。如果用--hard选项，那么工作目录也更新，如果用--soft选项，那么都不变。
&lt;img src="https://marklodato.github.io/visual-git-guide/reset-commit.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用--hard选项，工作目录也同样。
&lt;img src="https://marklodato.github.io/visual-git-guide/reset.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;如果给了文件名(或者 -p选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。
&lt;img src="https://marklodato.github.io/visual-git-guide/reset-files.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Merge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致fast-forward合并。指向只是简单的移动，并生成一个新的提交。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/merge-ff.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;否则就是一次真正的合并。默认把当前提交(ed489 如下所示)和另一个提交(33104)以及他们的共同祖父节点(b325c)进行一次三方合并。结果是先保存当前目录和索引，然后和父节点33104一起做一次新提交。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/merge.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cherry Pick&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cherry-pick命令"复制"一个提交节点并在当前分支做一次完全一样的新提交。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/cherry-pick.svg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rebase
rebase是merge命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/rebase.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;The above command takes all the commits that exist in topic but not in master (namely 169a6 and 2c33a), replays them onto master, and then moves the branch head to the new tip. Note that the old commits will be garbage collected if they are no longer referenced.&lt;/p&gt;

&lt;p&gt;To limit how far back to go, use the --onto option. The following command replays onto master the most recent commits on the current branch since 169a6 (exclusive), namely 2c33a.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://marklodato.github.io/visual-git-guide/rebase-onto.svg" alt=""&gt;&lt;/p&gt;

&lt;h3 id=""&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#technical-notes"&gt;图解Git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://git-scm.com/book/zh/v2"&gt;Git pro&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://git-scm.com/blog"&gt;Git blog&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>调试器是怎样工作的: Part 3 – 调试信息</title><description>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章里我会解释调试器是怎样在机器代码中找到C函数和变量,以及用来映射C代码和机器代码的数据.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id="debugginginformation"&gt;Debugging information&lt;/h4&gt;

&lt;p&gt;现代编译器非常擅长把带有缩进，控制结构和任意变量类型的高层次的代码，转换成一堆机器码。这样做的唯一目的就是希望程序能够尽可能的快。绝大部分的C代码会被转换成各种机器指令,而变量将被塞入栈,寄存器,或者是被优化得无影无踪.结构和代码甚至压根就不在输出代码中 — 它们只是那些被转换成相对于内存硬编码的偏移量的一种抽象。&lt;/p&gt;

&lt;p&gt;那么,当被要求在某个函数暂停时,调试器是如何知道对应的入口地址呢?当被要求显示某个变量的值时,调试器又是如何知道应该去哪里寻找变量呢? 答案便是–调试信息(debugging information).&lt;/p&gt;

&lt;p&gt;调试信息是由编译器在编译机器代码时一道生成的.它是可执行文件和源代码之间关系的一种描述.调试信息根据预定义的格式被编码到机器代码中.在过去的年代,对应于各种架构,有很多格式被发明了出来.因为本文的目的不在于研究这些格式的历史,而是研究它们是如何工作的,所以我们最好选定一种格式,它就是DWARF,在Linux平台和类Unix(Unix-y)平台上,DWARF被用来描述ELF格式可执行文件的调试信息,可以说,它无处不在.&lt;/p&gt;

&lt;h4 id="thedwarfintheelf"&gt;The DWARF in the ELF&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://eli.thegreenplace.net/images/2011/02/dwarf_logo.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;DWARF很复杂,它建立于对其他格式的多年研究经验之上,这些格式可以运用于各种架构.DWARF必须是复杂的,&lt;/p&gt;</description><link>http://localhost:2368/diao-shi-qi-shi-zen-yang-gong-zuo-de-part-3-diao-shi-xin-xi/</link><guid isPermaLink="false">b9f8302e-8d48-46da-a39e-463f48b559a0</guid><category>Debugger</category><category>Knowledge</category><dc:creator>Alchemist Li</dc:creator><pubDate>Tue, 15 Dec 2015 05:59:54 GMT</pubDate><content:encoded>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章里我会解释调试器是怎样在机器代码中找到C函数和变量,以及用来映射C代码和机器代码的数据.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id="debugginginformation"&gt;Debugging information&lt;/h4&gt;

&lt;p&gt;现代编译器非常擅长把带有缩进，控制结构和任意变量类型的高层次的代码，转换成一堆机器码。这样做的唯一目的就是希望程序能够尽可能的快。绝大部分的C代码会被转换成各种机器指令,而变量将被塞入栈,寄存器,或者是被优化得无影无踪.结构和代码甚至压根就不在输出代码中 — 它们只是那些被转换成相对于内存硬编码的偏移量的一种抽象。&lt;/p&gt;

&lt;p&gt;那么,当被要求在某个函数暂停时,调试器是如何知道对应的入口地址呢?当被要求显示某个变量的值时,调试器又是如何知道应该去哪里寻找变量呢? 答案便是–调试信息(debugging information).&lt;/p&gt;

&lt;p&gt;调试信息是由编译器在编译机器代码时一道生成的.它是可执行文件和源代码之间关系的一种描述.调试信息根据预定义的格式被编码到机器代码中.在过去的年代,对应于各种架构,有很多格式被发明了出来.因为本文的目的不在于研究这些格式的历史,而是研究它们是如何工作的,所以我们最好选定一种格式,它就是DWARF,在Linux平台和类Unix(Unix-y)平台上,DWARF被用来描述ELF格式可执行文件的调试信息,可以说,它无处不在.&lt;/p&gt;

&lt;h4 id="thedwarfintheelf"&gt;The DWARF in the ELF&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://eli.thegreenplace.net/images/2011/02/dwarf_logo.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;DWARF很复杂,它建立于对其他格式的多年研究经验之上,这些格式可以运用于各种架构.DWARF必须是复杂的,因为它需要解决一个很难办的问题–向调试器展示任何高级语言代码的调试信息,为各种架构和ABIs(application binary interface)提供支持.鄙文不足以详尽地阐释它,老实说,我对DWARF的各种阴暗面都还没有透彻的了解.在这片文章中,我采用动手的方式,来展示调试信息在实践中是如何被使用的.&lt;/p&gt;

&lt;h4 id="debugsectionsinelffiles"&gt;Debug sections in ELF files&lt;/h4&gt;

&lt;p&gt;首先,让我们看看DWARF信息在ELF文件内部何处.ELF定义了目标文件中的各种可选section,而section头表(section header table)则定义了存在哪些sections已经这些sections的名字.不同的工具以特殊的方式处理不同的sections -– birshuo,链接器读取某些sections,而调试器则读取另外的sections.&lt;/p&gt;

&lt;p&gt;作为实验,我们把下面的C程序编译成tracedprog2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;


void do_stuff(int my_arg)  
{
    int my_local = my_arg + 2;
    int i;

    for (i = 0; i &amp;lt; my_local; ++i)
        printf("i = %d\n", i);
}


int main()  
{
    do_stuff(2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用objdump -h把ELF文件的section头部打印出来.注意以.debug_开头的section –- 它们就是DWARF调试sections:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;26 .debug_aranges 00000020  00000000  00000000  00001037  
                 CONTENTS, READONLY, DEBUGGING
27 .debug_pubnames 00000028  00000000  00000000  00001057  
                 CONTENTS, READONLY, DEBUGGING
28 .debug_info   000000cc  00000000  00000000  0000107f  
                 CONTENTS, READONLY, DEBUGGING
29 .debug_abbrev 0000008a  00000000  00000000  0000114b  
                 CONTENTS, READONLY, DEBUGGING
30 .debug_line   0000006b  00000000  00000000  000011d5  
                 CONTENTS, READONLY, DEBUGGING
31 .debug_frame  00000044  00000000  00000000  00001240  
                 CONTENTS, READONLY, DEBUGGING
32 .debug_str    000000ae  00000000  00000000  00001284  
                 CONTENTS, READONLY, DEBUGGING
33 .debug_loc    00000058  00000000  00000000  00001332  
                 CONTENTS, READONLY, DEBUGGING
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些调试section的第1个数字表示该段大小,最后一个数字表示它在ELF文件中的偏移量.调试器使用这些信息从可执行文件读取section.&lt;/p&gt;

&lt;p&gt;现在,让我们看看在DWARF中找出有用信息的几个例子.&lt;/p&gt;

&lt;h4 id="findingfunctions"&gt;Finding functions&lt;/h4&gt;

&lt;p&gt;调试器最基本的功能就是在函数中设置断点,让调试器刚好在进入函数时暂停.为了实现这个功能,调试器必须了解高级语言中的函数与机器代码中这个函数的起始地址的映射信息.&lt;/p&gt;

&lt;p&gt;这个信息可以从DWARF中的.debug_info获得.在更进一步之前,先介绍一点背景.DWARF的最基本描述个体称为Debugging Information Entry (DIE).每个DIE有自己的标签 –- 它的类型, 一系列的属性.DIEs通过兄弟和儿子互联,属性值可以指向其他的DIE.&lt;/p&gt;

&lt;p&gt;运行命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objdump --dwarf=info tracedprog2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出很长,我们把注意力集中于这几行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;&amp;lt;71&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram)  
    &amp;lt;72&amp;gt;   DW_AT_external    : 1
    &amp;lt;73&amp;gt;   DW_AT_name        : (...): do_stuff
    &amp;lt;77&amp;gt;   DW_AT_decl_file   : 1
    &amp;lt;78&amp;gt;   DW_AT_decl_line   : 4
    &amp;lt;79&amp;gt;   DW_AT_prototyped  : 1
    &amp;lt;7a&amp;gt;   DW_AT_low_pc      : 0x8048604
    &amp;lt;7e&amp;gt;   DW_AT_high_pc     : 0x804863e
    &amp;lt;82&amp;gt;   DW_AT_frame_base  : 0x0      (location list)
    &amp;lt;86&amp;gt;   DW_AT_sibling     : &amp;lt;0xb3&amp;gt;

&amp;lt;1&amp;gt;: Abbrev Number: 9 (DW_TAG_subprogram)  
       DW_AT_external    : 1
       DW_AT_name        : (...): main
       DW_AT_decl_file   : 1
       DW_AT_decl_line   : 14
       DW_AT_type        : &amp;lt;0x4b&amp;gt;
       DW_AT_low_pc      : 0x804863e
       DW_AT_high_pc     : 0x804865a
       DW_AT_frame_base  : 0x2c     (location list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意有两个标签为&lt;code&gt;DW_TAG_subprogram&lt;/code&gt;的DIE,分别代表&lt;code&gt;do_stuff&lt;/code&gt;和&lt;code&gt;main&lt;/code&gt;,&lt;code&gt;DW_TAG_subprogram&lt;/code&gt;作为DWARF的术语,是指一个函数.每个section有各种属性,其中最值得探讨的是&lt;code&gt;DW_AT_low_pc&lt;/code&gt;.这是函数起始地址对应的EIP值.对&lt;code&gt;do_stuff&lt;/code&gt;来说,它是0x8048604.现在让我们看看这个地址在反汇编出来的代码中表示什么,objdump -d:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;08048604 :  
 8048604:       55           push   ebp
 8048605:       89 e5        mov    ebp,esp
 8048607:       83 ec 28     sub    esp,0x28
 804860a:       8b 45 08     mov    eax,DWORD PTR [ebp+0x8]
 804860d:       83 c0 02     add    eax,0x2
 8048610:       89 45 f4     mov    DWORD PTR [ebp-0xc],eax
 8048613:       c7 45 (...)  mov    DWORD PTR [ebp-0x10],0x0
 804861a:       eb 18        jmp    8048634 
 804861c:       b8 20 (...)  mov    eax,0x8048720
 8048621:       8b 55 f0     mov    edx,DWORD PTR [ebp-0x10]
 8048624:       89 54 24 04  mov    DWORD PTR [esp+0x4],edx
 8048628:       89 04 24     mov    DWORD PTR [esp],eax
 804862b:       e8 04 (...)  call   8048534 
 8048630:       83 45 f0 01  add    DWORD PTR [ebp-0x10],0x1
 8048634:       8b 45 f0     mov    eax,DWORD PTR [ebp-0x10]
 8048637:       3b 45 f4     cmp    eax,DWORD PTR [ebp-0xc]
 804863a:       7c e0        jl     804861c 
 804863c:       c9           leave
 804863d:       c3           ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确实,0x8048604就是do_stuff的起始地址,所以调试器可以将函数映射到它在可执行文件中的位置.&lt;/p&gt;

&lt;h4 id="findingvariables"&gt;Finding variables&lt;/h4&gt;

&lt;p&gt;假设进程已经中断在&lt;code&gt;do_stuff&lt;/code&gt;,我们想要调试器显示出变量&lt;code&gt;my_local&lt;/code&gt; 的值.调试器怎么知道它在哪里呢?事实上,这比找出函数更有难度.变量可以存在于全局变量区中,栈中,甚至是寄存器中.而且,相同的名字的变量在不同的作用域中可以有不同的值,调试信息必须能够反映出所有的这些变量,而DWARF确实做到了这一点.&lt;/p&gt;

&lt;p&gt;我不会讲解所有的可能(变量在全局变量区或者栈或者寄存器),就看看调试器怎么找出do&lt;em&gt;stuff中的my&lt;/em&gt;local吧.找到.debug&lt;em&gt;info,看一下do&lt;/em&gt;stuff对应的DIE,留意它的子DIE:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;1&amp;gt;&amp;lt;71&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram)  
    &amp;lt;72&amp;gt;   DW_AT_external    : 1
    &amp;lt;73&amp;gt;   DW_AT_name        : (...): do_stuff
    &amp;lt;77&amp;gt;   DW_AT_decl_file   : 1
    &amp;lt;78&amp;gt;   DW_AT_decl_line   : 4
    &amp;lt;79&amp;gt;   DW_AT_prototyped  : 1
    &amp;lt;7a&amp;gt;   DW_AT_low_pc      : 0x8048604
    &amp;lt;7e&amp;gt;   DW_AT_high_pc     : 0x804863e
    &amp;lt;82&amp;gt;   DW_AT_frame_base  : 0x0      (location list)
    &amp;lt;86&amp;gt;   DW_AT_sibling     : &amp;lt;0xb3&amp;gt;
 &amp;lt;2&amp;gt;&amp;lt;8a&amp;gt;: Abbrev Number: 6 (DW_TAG_formal_parameter)
    &amp;lt;8b&amp;gt;   DW_AT_name        : (...): my_arg
    &amp;lt;8f&amp;gt;   DW_AT_decl_file   : 1
    &amp;lt;90&amp;gt;   DW_AT_decl_line   : 4
    &amp;lt;91&amp;gt;   DW_AT_type        : &amp;lt;0x4b&amp;gt;
    &amp;lt;95&amp;gt;   DW_AT_location    : (...)       (DW_OP_fbreg: 0)
 &amp;lt;2&amp;gt;&amp;lt;98&amp;gt;: Abbrev Number: 7 (DW_TAG_variable)
    &amp;lt;99&amp;gt;   DW_AT_name        : (...): my_local
    &amp;lt;9d&amp;gt;   DW_AT_decl_file   : 1
    &amp;lt;9e&amp;gt;   DW_AT_decl_line   : 6
    &amp;lt;9f&amp;gt;   DW_AT_type        : &amp;lt;0x4b&amp;gt;
       DW_AT_location    : (...)      (DW_OP_fbreg: -20)
&amp;lt;2&amp;gt;: Abbrev Number: 8 (DW_TAG_variable)  
       DW_AT_name        : i
       DW_AT_decl_file   : 1
       DW_AT_decl_line   : 7
       DW_AT_type        : &amp;lt;0x4b&amp;gt;
       DW_AT_location    : (...)      (DW_OP_fbreg: -24)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意每个DIE中第一个尖括号里的序号.这说明在第几层 — 在这个例子中,&amp;lt;2&gt;DIE是&amp;lt;1&gt;DIE的儿子.可以看到,变量&lt;code&gt;my_local&lt;/code&gt;(标签为&lt;code&gt;DW_TAG_variable&lt;/code&gt;)是函数&lt;code&gt;do_stuff&lt;/code&gt;的儿子.调试器对变量类型也很感兴趣,因为这样她才能正确的显示变量值,这里变量&lt;code&gt;my_local&lt;/code&gt;的类型指向另外一个DIE – &amp;lt;0x4b&gt;.查找objdump的输出,可以看到它表示4字节长的有符号整数.&lt;/p&gt;

&lt;p&gt;为了在进程内存映像中定位变量,调试器会查看&lt;code&gt;DW_AT_location&lt;/code&gt;属性. 对&lt;code&gt;my_local&lt;/code&gt;来说,它是&lt;code&gt;DW_OP_fbreg: -20&lt;/code&gt;.这意味着变量存储在函数栈帧底部(&lt;code&gt;DW_AT_frame_base&lt;/code&gt;)偏移&lt;code&gt;-20&lt;/code&gt;的位置.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_stuff&lt;/code&gt;的&lt;code&gt;DW_AT_frame_base&lt;/code&gt;属性为0x0 (location list),这说明值需要到&lt;code&gt;location list section&lt;/code&gt;中查找.命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump --dwarf=loc tracedprog2

tracedprog2:     file format elf32-i386

Contents of the .debug_loc section:

    Offset   Begin    End      Expression
    00000000 08048604 08048605 (DW_OP_breg4: 4 )
    00000000 08048605 08048607 (DW_OP_breg4: 8 )
    00000000 08048607 0804863e (DW_OP_breg5: 8 )
    00000000 
    0000002c 0804863e 0804863f (DW_OP_breg4: 4 )
    0000002c 0804863f 08048641 (DW_OP_breg4: 8 )
    0000002c 08048641 0804865a (DW_OP_breg5: 8 )
    0000002c 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们感兴趣的location信息是第一个[4].它指出了当前的栈底地址,变量在这个栈底地址的偏移量被当成是离寄存器值的偏移量计算.对x86来说,bpreg4指esp,bpreg5指ebp.&lt;/p&gt;

&lt;p&gt;看看do_stuff的前几条指令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;08048604 :  
 8048604:       55          push   ebp
 8048605:       89 e5       mov    ebp,esp
 8048607:       83 ec 28    sub    esp,0x28
 804860a:       8b 45 08    mov    eax,DWORD PTR [ebp+0x8]
 804860d:       83 c0 02    add    eax,0x2
 8048610:       89 45 f4    mov    DWORD PTR [ebp-0xc],eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ebp在第2条指令之后才变得有意义,一旦ebp是有效的,我们就可以计算到它的偏移量,因为ebp一直保持不变,而esp随着数据的入栈和出栈而增减.&lt;/p&gt;

&lt;p&gt;那么my&lt;em&gt;local到底在哪里呢?我们只对0x8048610指令后my&lt;/em&gt;local的值有兴趣 (在eax中计算后,my&lt;em&gt;local值被放回内存中),所以调试器将利用DW&lt;/em&gt;OP&lt;em&gt;breg5: 8来寻找它. 回忆一下,my&lt;/em&gt;local的DW&lt;em&gt;AT&lt;/em&gt;location属性是DW&lt;em&gt;OP&lt;/em&gt;fbreg: -20.让我们做一点计算吧: 栈底偏移-20,而栈底是ebp+8,得出地址是ebp – 12.看一下反汇编出来的代码 –- 确实,my_local就是存储在ebp-12中.&lt;/p&gt;

&lt;h4 id="lookinguplinenumbers"&gt;Looking up line numbers&lt;/h4&gt;

&lt;p&gt;好吧,我承认,在谈到找出调试信息中的函数时,我小小的作弊了.当我们调试C代码,在函数中设置断点时,我们经常对相关机器指令的第一句是没有什么兴趣的.我们真正感兴趣的是,C代码中函数的第一行.&lt;/p&gt;

&lt;p&gt;这就是为什么DWARF保存中C代码行号和可执行文件中机器指令的完全映射信息的原因.这些信息由.debug_line记录,我们可以用如下命令查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump --dwarf=decodedline tracedprog2

tracedprog2:     file format elf32-i386

Decoded dump of debug contents of section .debug_line:

CU: /home/eliben/eli/eliben-code/debugger/tracedprog2.c:  
File name           Line number    Starting address  
tracedprog2.c                5           0x8048604  
tracedprog2.c                6           0x804860a  
tracedprog2.c                9           0x8048613  
tracedprog2.c               10           0x804861c  
tracedprog2.c                9           0x8048630  
tracedprog2.c               11           0x804863c  
tracedprog2.c               15           0x804863e  
tracedprog2.c               16           0x8048647  
tracedprog2.c               17           0x8048653  
tracedprog2.c               18           0x8048658  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第5行指向do&lt;em&gt;stuff入口地址 -– 0x8040604.第6行是断点在do&lt;/em&gt;stuff时,调试器需要暂停的真实地址,它指向0x804860a,这是函数真正工作的开始.这些line信息允许调试器很容易地在行号和地址之间做双向映射:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当被要求在某行设置断点时,调试器找出需要设置中断的地址(能想起上篇文章提到的int 3吗?)&lt;/li&gt;
&lt;li&gt;当一个指令产生段错误时,调试器很容易找出代码所在行.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="libdwarfworkingwithdwarfprogrammatically"&gt;libdwarf – Working with DWARF programmatically&lt;/h4&gt;

&lt;p&gt;尽管使用获取DWARF信息的一些命令行工具很有用,但是它们还不太令人满意.作为程序员,我们想要编写自己的程序,它可以读取格式,提取出我们想要的信息.&lt;/p&gt;

&lt;p&gt;当然,一种途径就是掌握DWARF细节,然后开始造轮子.但是,记得人们千叮咛万嘱咐,一定要用库,而不是自己手工写一个HTML解析器吗? 好吧,对DWARF来说,更该如此,它比HTML复杂多了.文中展示的只是冰山一角,更糟糕的是,很多信息是被很紧凑地压缩在目标文件中的&lt;/p&gt;

&lt;p&gt;既然如此,我们就选择另外一条道路吧,我们可以使用DWARF库.主要有两种:
1. BFD (libbfd) — 它被GNU binutils选中,包括文中大放异彩的objdump, ld(链接器) 和 as (汇编器). &lt;br&gt;
2. libdwarf –- 它和libelf被拿来开发了Solaris和FreeBSD上的很多工具&lt;/p&gt;

&lt;p&gt;我选择libdwarf而不是BFD,因为我觉得没那么晦涩,而且它的授权也比较宽松(LGPL vs. GPL).&lt;/p&gt;

&lt;p&gt;因为libdwarf本身就是很复杂的,所以我们需要编写很多代码来使用它.我不打算展示这些代码,你可以在&lt;a href="https://github.com/eliben/code-for-blog/blob/master/2011/dwarf_get_func_addr.c"&gt;这里&lt;/a&gt;下载源文件.要编译代码,你需要安装libelf和libdwarf,然后向链接器传递-lelf和-ldwarf标志.&lt;/p&gt;

&lt;p&gt;下载的代码编译出来的程序需要一个参数作为目标文件,它分析出目标文件的函数和对应的入口地址,就像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dwarf_get_func_addr tracedprog2
DW_TAG_subprogram: 'do_stuff'  
low pc  : 0x08048604  
high pc : 0x0804863e  
DW_TAG_subprogram: 'main'  
low pc  : 0x0804863e  
high pc : 0x0804865a  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;libdwarf文档很不错,通过一点努力,我们很容易就可以找出DWARF sections的其他信息.&lt;/p&gt;</content:encoded></item><item><title>调试器是怎样工作的: Part 2 – 断点</title><description>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来展示一下断点是如何在调试器里实现的。断点是调试器的两大杀器之一，另外一个是可以查看被调试进程的内存。在上一篇中我们已经大致看到了第二个杀器的缩影，但是断点仍然是很神秘。不过看完这篇后，一切会水落石出。&lt;/p&gt;

&lt;h4 id="softwareinterrupts"&gt;Software interrupts&lt;/h4&gt;

&lt;p&gt;为了在x86架构上实现断点，我们使用了软中断（也叫&lt;code&gt;traps&lt;/code&gt;)。在我们一猛子扎到细节之前，我先解释一下&lt;code&gt;interrupt&lt;/code&gt;和&lt;code&gt;trap&lt;/code&gt;的概念。&lt;/p&gt;

&lt;p&gt;CPU可以看成是指令流，一条一条的执行指令。为了处理异步事件（比如IO或者硬件计时器），CPU使用&lt;code&gt;interrupt&lt;/code&gt;。一个硬件&lt;code&gt;interrupt&lt;/code&gt;通常是一个专门的电子信号，挂载了一段特殊的响应电路。这个电路发出&lt;code&gt;interrupt&lt;/code&gt;开始的通知，并且把CPU暂停在它当前执行的指令上，然后保存状态，接下来跳转到预先定好的一段处理代码处。但这段处理&lt;code&gt;interrupt&lt;/code&gt;代码执行完毕后，CPU再恢复现场，从暂停处执行。&lt;/p&gt;

&lt;p&gt;软件&lt;code&gt;interrupt&lt;/code&gt;原理上和硬件&lt;code&gt;interrupt&lt;/code&gt;一样，不过具体上有一些不同。 CPU支持特殊的指令来模拟&lt;code&gt;interrupt&lt;/code&gt;&lt;/p&gt;</description><link>http://localhost:2368/diao-shi-qi-shi-zen-yang-gong-zuo-de-part-2-duan-dian/</link><guid isPermaLink="false">9e097196-c617-478e-a325-99eb442d92db</guid><category>Debugger</category><category>Knowledge</category><dc:creator>Alchemist Li</dc:creator><pubDate>Mon, 14 Dec 2015 14:40:43 GMT</pubDate><content:encoded>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来展示一下断点是如何在调试器里实现的。断点是调试器的两大杀器之一，另外一个是可以查看被调试进程的内存。在上一篇中我们已经大致看到了第二个杀器的缩影，但是断点仍然是很神秘。不过看完这篇后，一切会水落石出。&lt;/p&gt;

&lt;h4 id="softwareinterrupts"&gt;Software interrupts&lt;/h4&gt;

&lt;p&gt;为了在x86架构上实现断点，我们使用了软中断（也叫&lt;code&gt;traps&lt;/code&gt;)。在我们一猛子扎到细节之前，我先解释一下&lt;code&gt;interrupt&lt;/code&gt;和&lt;code&gt;trap&lt;/code&gt;的概念。&lt;/p&gt;

&lt;p&gt;CPU可以看成是指令流，一条一条的执行指令。为了处理异步事件（比如IO或者硬件计时器），CPU使用&lt;code&gt;interrupt&lt;/code&gt;。一个硬件&lt;code&gt;interrupt&lt;/code&gt;通常是一个专门的电子信号，挂载了一段特殊的响应电路。这个电路发出&lt;code&gt;interrupt&lt;/code&gt;开始的通知，并且把CPU暂停在它当前执行的指令上，然后保存状态，接下来跳转到预先定好的一段处理代码处。但这段处理&lt;code&gt;interrupt&lt;/code&gt;代码执行完毕后，CPU再恢复现场，从暂停处执行。&lt;/p&gt;

&lt;p&gt;软件&lt;code&gt;interrupt&lt;/code&gt;原理上和硬件&lt;code&gt;interrupt&lt;/code&gt;一样，不过具体上有一些不同。 CPU支持特殊的指令来模拟&lt;code&gt;interrupt&lt;/code&gt;，触发同样的过程。这样的软件&lt;code&gt;trap&lt;/code&gt;使得现代操作系统的许多奇迹（任务调度，虚拟内存，内存保护，调试）实现起来易如反掌。&lt;/p&gt;

&lt;p&gt;但是一些程序错误（比如说除以0）也被CPU当作&lt;code&gt;trap&lt;/code&gt;，并且经常被称作&lt;code&gt;exception&lt;/code&gt;。在这里硬件和软件的边界变的模糊，因为很难说这是硬件还是软件的中断。书归正传。&lt;/p&gt;

&lt;h4 id="int3intheory"&gt;int 3 in theory&lt;/h4&gt;

&lt;p&gt;经过前面的部分，我现在可以简单的说，断点就是通过CPU的特殊指令触发&lt;code&gt;trap&lt;/code&gt;，这个指令叫做int 3。int就是&lt;code&gt;trap&lt;/code&gt;指令在x86上的术语。x86支持&lt;code&gt;int&lt;/code&gt;指令带有一个8-bit的参数。参数指明了哪种中断发生的，所以理论上支持256种中断。头32个中断是被CPU保留下来给自己用的，数字3就是我们目前感兴趣的，被称作&lt;code&gt;trap to debugger&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;进一步之前，我们看看文档怎么说的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;INT 3&lt;/code&gt;指令产生出一个特殊的字节操作码（CC),它的目的是用来调用调试异常处理程序。（单字节的形式是精心设计的，因为它可以被用来替换任何带有断点的指令的第一个字节，包括单字节指令，并且不会覆盖掉其他代码）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;括号里面的内容相当重要,但是现在解释还是为时过早了,在文章后半部分我们再做回顾.&lt;/p&gt;

&lt;h4 id="int3inpractice"&gt;int 3 in practice&lt;/h4&gt;

&lt;p&gt;说完理论，让我们看下如何用&lt;code&gt;int 3&lt;/code&gt;来实现断点&lt;/p&gt;

&lt;p&gt;这个其实做起来很简单。一旦你的进程执行了&lt;code&gt;int 3&lt;/code&gt;指令，操作系统就会挂起它。在Linux上，系统会给进程发送一个信号&lt;code&gt;SIGTRAP&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这就是全部。回忆一下第一部分，每当子进程收到信号的时候，父进程都会收到通知。现在你可以大概猜出来我们会怎么做了&lt;/p&gt;

&lt;p&gt;让我们来看一下代码&lt;/p&gt;

&lt;h4 id="settingbreakpointsmanually"&gt;Setting breakpoints manually&lt;/h4&gt;

&lt;p&gt;先看一下目标程序&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-`"&gt;section    .text  
    ; The _start symbol must be declared for the linker (ld)
    global _start

_start:

    ; Prepare arguments for the sys_write system call:
    ;   - eax: system call number (sys_write)
    ;   - ebx: file descriptor (stdout)
    ;   - ecx: pointer to string
    ;   - edx: string length
    mov     edx, len1
    mov     ecx, msg1
    mov     ebx, 1
    mov     eax, 4

    ; Execute the sys_write system call
    int     0x80

    ; Now print the other message
    mov     edx, len2
    mov     ecx, msg2
    mov     ebx, 1
    mov     eax, 4
    int     0x80

    ; Execute sys_exit
    mov     eax, 1
    int     0x80

section    .data

msg1    db      'Hello,', 0xa  
len1    equ     $ - msg1  
msg2    db      'world!', 0xa  
len2    equ     $ - msg2  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我们希望在第一次输出之后,在第2次输出之前插入断点,也就是在第一个&lt;code&gt;int 0x80&lt;/code&gt;之后,在&lt;code&gt;mov edx, len2&lt;/code&gt;之前.首先我们需要知道这条指令&lt;code&gt;mov edx, len2&lt;/code&gt;被映射到虚拟内存何处,跑一下objdump -d:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;traced_printer2:     file format elf32-i386

Sections:  
Idx Name          Size      VMA       LMA       File off  Algn  
  0 .text         00000033  08048080  08048080  00000080  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  080490b4  080490b4  000000b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .text:

08048080 &amp;lt;.text&amp;gt;:  
 8048080:     ba 07 00 00 00          mov    $0x7,%edx
 8048085:     b9 b4 90 04 08          mov    $0x80490b4,%ecx
 804808a:     bb 01 00 00 00          mov    $0x1,%ebx
 804808f:     b8 04 00 00 00          mov    $0x4,%eax
 8048094:     cd 80                   int    $0x80
 8048096:     ba 07 00 00 00          mov    $0x7,%edx
 804809b:     b9 bb 90 04 08          mov    $0x80490bb,%ecx
 80480a0:     bb 01 00 00 00          mov    $0x1,%ebx
 80480a5:     b8 04 00 00 00          mov    $0x4,%eax
 80480aa:     cd 80                   int    $0x80
 80480ac:     b8 01 00 00 00          mov    $0x1,%eax
 80480b1:     cd 80                   int    $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到,断点所在位置为0×8048096&lt;/p&gt;

&lt;h4 id="settingbreakpointsinthedebuggerwithint3"&gt;Setting breakpoints in the debugger with int 3&lt;/h4&gt;

&lt;p&gt;在被跟踪进程的某个特定地址插入断点,跟踪进程需要:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;记住目的地址的数据  &lt;/li&gt;
&lt;li&gt;将目的地址的第一个字节修改为int 3指令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后,跟踪进程通知OS恢复被跟踪进程的运行(通过PTRACE_CONT),被跟踪进程一直运行,直到执行int 3指令后,OS向它发送一个信号使之再一次暂停.这时,跟踪进程也将接收到一个表示子进程(或被跟踪进程)已经暂停的信号,再一次插手:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将目的地址对应的int 3指令恢复为原来的数据  &lt;/li&gt;
&lt;li&gt;回滚EIP(减1).因为执行int 3指令后,EIP将指向它的下一条指令  &lt;/li&gt;
&lt;li&gt;与被跟踪进程做些其他交互,因为这时被跟踪进程仍然在目的地址处暂停.调试器也就是在这时告诉你变量值,调用栈等等的.  &lt;/li&gt;
&lt;li&gt;这时候如果用户希望被跟踪进程继续运行,那么跟踪进程将负责在目的地址重新设置断点(在step 1被移除了),除非用户明确要求取消断点.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们看一下这些步骤是如何被转化为代码的吧.我们将借鉴part 1中的模板(fork一个子进程并跟踪它).完整的源代码请见后文.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Obtain and show child's instruction pointer */
ptrace(PTRACE_GETREGS, child_pid, 0, &amp;amp;regs);  
procmsg("Child started. EIP = 0x%08x\n", regs.eip);

/* Look at the word at the address we're interested in */
unsigned addr = 0x8048096;  
unsigned data = ptrace(PTRACE_PEEKTEXT, child_pid, (void*)addr, 0);  
procmsg("Original data at 0x%08x: 0x%08x\n", addr, data);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟踪进程读出被跟踪进程的eip寄存器值,保存0×8048096对应的第一个字节.如果我们跟踪上文列出的汇编程序,输出如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[13028] Child started. EIP = 0x08048080
[13028] Original data at 0x08048096: 0x000007ba
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Write the trap instruction 'int 3' into the address */
unsigned data_with_trap = (data &amp;amp; 0xFFFFFF00) | 0xCC;  
ptrace(PTRACE_POKETEXT, child_pid, (void*)addr, (void*)data_with_trap);

/* See what's there again... */
unsigned readback_data = ptrace(PTRACE_PEEKTEXT, child_pid, (void*)addr, 0);  
procmsg("After trap, data at 0x%08x: 0x%08x\n", addr, readback_data);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意int 3是怎样被插入目的地址的.输出为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[13028] After trap, data at 0x08048096: 0x000007cc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟踪进程这时让被跟踪进程继续运行,直到它在断点处暂停:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Let the child run to the breakpoint and wait for it to
** reach it
*/
ptrace(PTRACE_CONT, child_pid, 0, 0);

wait(&amp;amp;wait_status);  
if (WIFSTOPPED(wait_status)) {  
    procmsg("Child got a signal: %s\n", strsignal(WSTOPSIG(wait_status)));
}
else {  
    perror("wait");
    return;
}

/* See where the child is now */
ptrace(PTRACE_GETREGS, child_pid, 0, &amp;amp;regs);  
procmsg("Child stopped at EIP = 0x%08x\n", regs.eip);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello,  
[13028] Child got a signal: Trace/breakpoint trap
[13028] Child stopped at EIP = 0x08048097
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到,”Hello,”在断点之前输出,而且这时候,被跟踪进程在执行int 3后立刻暂停.&lt;/p&gt;

&lt;p&gt;最后,根据上文的解释,要让被跟踪进程继续运行,我们需要将中断指令恢复成原来的指令.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Remove the breakpoint by restoring the previous data
** at the target address, and unwind the EIP back by 1 to
** let the CPU execute the original instruction that was
** there.
*/
ptrace(PTRACE_POKETEXT, child_pid, (void*)addr, (void*)data);  
regs.eip -= 1;  
ptrace(PTRACE_SETREGS, child_pid, 0, &amp;amp;regs);

/* The child can continue running now */
ptrace(PTRACE_CONT, child_pid, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被跟踪进程输出”world!”,然后退出.&lt;/p&gt;

&lt;p&gt;注意,在这里我们没有重新设置断点.如果要重新设置的话,我们让被跟踪进程单步执行(PTRACE&lt;em&gt;SINGLE)0x08048096对应的原来执行,然后插回断点,并让被跟踪进程继续运行(PTRACE&lt;/em&gt;CONT).下文的debug库实现了这个功能.&lt;/p&gt;

&lt;h4 id="moreonint3"&gt;More on int 3&lt;/h4&gt;

&lt;p&gt;让我们温习一下int 3和它古怪的说明:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单字节的形式是精心设计的，因为它可以被用来替换任何带有断点的指令的第一个字节，包括单字节指令，并且不会覆盖掉其他代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;x86上的int指令占据两个字节 –- “0xcd”之后是中断号.如果你将int 3指令直接code成cd 03,那就上当啦,哈哈.因为在x86的实现上,int 3对应的是单字节指令0xcc.&lt;/p&gt;

&lt;p&gt;诡异,为什么会这样呢? 因为只有单字节才允许我们不篡改其他指令地插入断点,再次强调,这是很重要的.考虑下面的样例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .. some code ..
    jz    foo
    dec   eax
foo:  
    call  bar
    .. some code ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想要在dec eax对应的地址插入断点.dec eax的机器码正好是一个字节的(0x48),如果插入的断点机器码超出了一个字节,那么dec eax的下一指令(call)将不可避免的被篡改, 这会让程序产生不可预料的错误.&lt;/p&gt;

&lt;p&gt;将int 3设计成单字节指令就是为了解决这个问题的.因为x86上的指令最短为一个字节,所以,我们可以确定只修改了目的指令.&lt;/p&gt;

&lt;h4 id="encapsulatingsomegorydetails"&gt;Encapsulating some gory details&lt;/h4&gt;

&lt;p&gt;为了省事,我把上文提到的龌龊底层和细节封装到API中,命名为库debuglib.接下来就看展示吧.&lt;/p&gt;

&lt;h4 id="tracingacprogram"&gt;Tracing a C program&lt;/h4&gt;

&lt;p&gt;目前,我们仅仅跟踪过汇编程序.是时候跟踪C程序了.&lt;/p&gt;

&lt;p&gt;出乎意料的,其实这也没有什么不一样的 — 只是找出断点的地址有点困难而已.考虑这个简单的程序:&lt;/p&gt;

&lt;h1 id="includestdioh"&gt;include &lt;stdio.h&gt;&lt;/stdio.h&gt;&lt;/h1&gt;

&lt;p&gt;void do_stuff() &lt;br&gt;
{
    printf("Hello, ");
}&lt;/p&gt;

&lt;p&gt;int main() &lt;br&gt;
{
    for (int i = 0; i &amp;lt; 4; ++i)
        do&lt;em&gt;stuff();
    printf("world!\n");
    return 0;
}
在函数do&lt;/em&gt;stuff的入口我们想要插入一个断点.借助我们的老朋友 — objdump,我们可以很方便地反汇编.因为text段包含了很多C库初始化代码,我们对它没有什么兴趣.还是直接搜索do_stuff吧:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;080483e4 :  
 80483e4:     55                      push   %ebp
 80483e5:     89 e5                   mov    %esp,%ebp
 80483e7:     83 ec 18                sub    $0x18,%esp
 80483ea:     c7 04 24 f0 84 04 08    movl   $0x80484f0,(%esp)
 80483f1:     e8 22 ff ff ff          call   8048318

 80483f6:     c9                      leave
 80483f7:     c3                      ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK,do&lt;em&gt;stuff入口地址是0×080483e4,它对应着do&lt;/em&gt;stuff函数的第一条指令.用debuglib库实现跟踪进程如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void run_debugger(pid_t child_pid)  
{
    procmsg("debugger started\n");

    /* Wait for child to stop on its first instruction */
    wait(0);
    procmsg("child now at EIP = 0x%08x\n", get_child_eip(child_pid));

    /* Create breakpoint and run to it*/
    debug_breakpoint* bp = create_breakpoint(child_pid, (void*)0x080483e4);
    procmsg("breakpoint created\n");
    ptrace(PTRACE_CONT, child_pid, 0, 0);
    wait(0);

    /* Loop as long as the child didn't exit */
    while (1) {
        /* The child is stopped at a breakpoint here. Resume its
        ** execution until it either exits or hits the
        ** breakpoint again.
        */
        procmsg("child stopped at breakpoint. EIP = 0x%08X\n", get_child_eip(child_pid));
        procmsg("resuming\n");
        int rc = resume_from_breakpoint(child_pid, bp);

        if (rc == 0) {
            procmsg("child exited\n");
            break;
        }
        else if (rc == 1) {
            continue;
        }
        else {
            procmsg("unexpected: %d\n", rc);
            break;
        }
    }

    cleanup_breakpoint(bp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用create&lt;em&gt;breakpoint, resume&lt;/em&gt;from&lt;em&gt;breakpoint和cleanup&lt;/em&gt;breakpoint来避免直接修改EIP和目标进程的内存.看一下输出吧:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bp_use_lib traced_c_loop
[13363] debugger started
[13364] target started. will run 'traced_c_loop'
[13363] child now at EIP = 0x00a37850
[13363] breakpoint created
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,  
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,  
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,  
[13363] child stopped at breakpoint. EIP = 0x080483E5
[13363] resuming
Hello,  
world!  
[13363] child exited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as expected!&lt;/p&gt;</content:encoded></item><item><title>调试器是怎样工作的: Part 1-基础篇</title><description>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在这篇文章中,我将解释实现Linux下的调试器的基石–ptrace系统调用.本文的所有例子都是在32位Ubuntu上编写的,需要注意的是,这些代码是高度依赖于计算机体系结构的,好在移植他们应该不会太难.&lt;/p&gt;

&lt;p&gt;这里我们想搞明白，到底怎样才能让调试器可以工作起来呢？
调试器可以启动一个进程并调试之,或者将自己attach到一个正在运行的进程.调试器还可以在代码中单步执行,设置断点,到断点停住，查看变量值和堆栈跟踪信息(stack trace)。很多调试器还有一些高级特性,比如说执行表达式,调用在被调试进程空间中的函数,甚至对正在运行的进程的代码做出on-the-fly的修改,并监测它带来的影响。&lt;/p&gt;

&lt;p&gt;现代调试器都是集合了各种特技的怪兽,但是它们的实现基础却出奇的简单。调试器不过是使用了操作系统和编译器/链接器提供的一些基础服务罢了,剩下的就是一些体力劳动了。&lt;/p&gt;

&lt;h4 id="linuxdebuggingptrace"&gt;Linux debugging - ptrace&lt;/h4&gt;

&lt;p&gt;Linux下调试器的大杀器正是&lt;code&gt;ptrace&lt;/code&gt;系统调用. 它功能强而复杂的工具,它允许一个进程控制另外一个进程,甚至能够peek and poke被跟踪进程的内部.对ptrace的详细解释至少需要半本书的篇幅,所以下面我重点着墨于ptrace的使用.&lt;/p&gt;

&lt;p&gt;现在,让我们开始吧.&lt;/p&gt;

&lt;h4 id="steppingthroughthecodeofaprocess"&gt;Stepping through the code of&lt;/h4&gt;</description><link>http://localhost:2368/geng-qing-liang-de-view-controllers/</link><guid isPermaLink="false">d2b05321-1e0a-42b4-8d6a-5c1a0ad523b3</guid><category>Debugger</category><category>Knowledge</category><dc:creator>Alchemist Li</dc:creator><pubDate>Sun, 13 Dec 2015 12:23:06 GMT</pubDate><content:encoded>&lt;p&gt;翻译自&lt;a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1"&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在这篇文章中,我将解释实现Linux下的调试器的基石–ptrace系统调用.本文的所有例子都是在32位Ubuntu上编写的,需要注意的是,这些代码是高度依赖于计算机体系结构的,好在移植他们应该不会太难.&lt;/p&gt;

&lt;p&gt;这里我们想搞明白，到底怎样才能让调试器可以工作起来呢？
调试器可以启动一个进程并调试之,或者将自己attach到一个正在运行的进程.调试器还可以在代码中单步执行,设置断点,到断点停住，查看变量值和堆栈跟踪信息(stack trace)。很多调试器还有一些高级特性,比如说执行表达式,调用在被调试进程空间中的函数,甚至对正在运行的进程的代码做出on-the-fly的修改,并监测它带来的影响。&lt;/p&gt;

&lt;p&gt;现代调试器都是集合了各种特技的怪兽,但是它们的实现基础却出奇的简单。调试器不过是使用了操作系统和编译器/链接器提供的一些基础服务罢了,剩下的就是一些体力劳动了。&lt;/p&gt;

&lt;h4 id="linuxdebuggingptrace"&gt;Linux debugging - ptrace&lt;/h4&gt;

&lt;p&gt;Linux下调试器的大杀器正是&lt;code&gt;ptrace&lt;/code&gt;系统调用. 它功能强而复杂的工具,它允许一个进程控制另外一个进程,甚至能够peek and poke被跟踪进程的内部.对ptrace的详细解释至少需要半本书的篇幅,所以下面我重点着墨于ptrace的使用.&lt;/p&gt;

&lt;p&gt;现在,让我们开始吧.&lt;/p&gt;

&lt;h4 id="steppingthroughthecodeofaprocess"&gt;Stepping through the code of a process&lt;/h4&gt;

&lt;p&gt;这里有一份代码,它是一个处于&lt;code&gt;traced&lt;/code&gt;模式的进程, CPU将单步执行的它机器代码(汇编指令).我会分几部分的展示这些代码，解释每一个部分，在文章的最后你可以找到可以编译的完整的C文件。&lt;/p&gt;

&lt;p&gt;代码分为两部分,一部分是执行用户所提供的指令(user-supplied command)的子进程,另外一部分是一个父进程,它跟踪子进程.下面是main函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char** argv)  
{
    pid_t child_pid;

    if (argc &amp;lt; 2) {
        fprintf(stderr, "Expected a program name as argument\n");
        return -1;
    }

    child_pid = fork();
    if (child_pid == 0)
        run_target(argv[1]);
    else if (child_pid &amp;gt; 0)
        run_debugger(child_pid);
    else {
        perror("fork");
        return -1;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码很简单: 用fork创建一个子进程. 第二条if语句运行子进程(这里叫做”target”),接下来的else if 分支执行父进程(这里叫做”debugger”).&lt;/p&gt;

&lt;p&gt;这是target的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void run_target(const char* programname)  
{
    procmsg("target started. will run '%s'\n", programname);

    /* Allow tracing of this process */
    if (ptrace(PTRACE_TRACEME, 0, 0, 0) &amp;lt; 0) {
        perror("ptrace");
        return;
    }

    /* Replace this process's image with the given program */
    execl(programname, programname, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里最有意思的就是ptrace语句.ptrace原型如下(in sys/ptrace.h):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long ptrace(enum __ptrace_request request, pid_t pid,  
                 void *addr, void *data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数request的取值范围包括了很多的预定义的常数PTRACE&lt;em&gt;*。第二个参数指定了request起作用的进程ID.参数addr和data分别是地址和指向数据的指针,它们可以用来操作内存.上面代码中的ptrace做出了PTRACE&lt;/em&gt;TRACEME请求,意味着子进程通知操作系统,让父进程跟踪自己.PTRACE_TRACEME在man-page中有很清楚的解释:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PTRACE&lt;em&gt;TRACEME表明父进程可以跟踪子进程,任何信号(除了SIGKILL)都会暂停子进程,并且通过wait()来通知它的父进程。&lt;strong&gt;子进程内部对exec()的调用将发出SIGTRAP信号,这可以让父进程在子进程新程序开始运行之前就完全控制它&lt;/strong&gt;.如果父进程不打算跟踪子进程,子进程就不应该发出PTRACE&lt;/em&gt;TRACEME请求.(在PTRACE_TRACEME请求时,参数pid,addr和data被忽略.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与我们例子相关的解释已经高亮出来了。run_target在做出ptrace调用之后的第一步,就是用execl执行参数programname.正如引文解释的那样,子进程在执行execl的新程序之前会被暂停,而且父进程将收到OS发送的信号.&lt;/p&gt;

&lt;p&gt;是时候看看父进程了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void run_debugger(pid_t child_pid)  
{
    int wait_status;
    unsigned icounter = 0;
    procmsg("debugger started\n");

    /* Wait for child to stop on its first instruction */
    wait(&amp;amp;wait_status);

    while (WIFSTOPPED(wait_status)) {
        icounter++;
        /* Make the child execute another instruction */
        if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) &amp;lt; 0) {
            perror("ptrace");
            return;
        }

        /* Wait for child to stop on its next instruction */
        wait(&amp;amp;wait_status);
    }

    procmsg("the child executed %u instructions\n", icounter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall from above that once the child starts executing the exec call, it will stop and be sent the SIGTRAP signal. The parent here waits for this to happen with the first wait call. wait will return once something interesting happens, and the parent checks that it was because the child was stopped (WIFSTOPPED returns true if the child process was stopped by delivery of a signal). &lt;br&gt;
回忆一下,子进程内部执行exec调用,它将会停下，并收到SIGTRAP信号。父进程中的第一条wait()就是等待发生这个情况。一旦有有趣的事情发生，wait将会返回。这时父进程检查就会发现这是由于子进程停止引发的。（WIFSTOPPED在子进程由于信号被暂停时，会返回true）&lt;/p&gt;

&lt;p&gt;接下来发生的就是最有趣的事了,父进程通过参数 PTRACE_SINGLESTEP，和子进程的id值做ptrace调用,告诉操作系统,重新唤醒子进程,但是在每条机器指令运行之后暂停.再一次的,父进程阻塞等待子进程暂停并计数,子进程结束(WIFEXITED会返回true)后,父进程跳出loop循环.&lt;/p&gt;

&lt;p&gt;icounter对子进程执行的每条指令计数.所以我们简单的例子也做了有用的事情，从命令行给定一个程序的名字，它会执行这个程序，然后汇报出这个程序从开始到结束执行了多少条cpu指令。我们来动手试试。&lt;/p&gt;

&lt;h4 id="atestrun"&gt;A test run&lt;/h4&gt;

&lt;p&gt;编译下面的代码,运行之,让它被跟踪.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main()  
{
    printf("Hello, world!\n");
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出乎意料的,跟踪进程执行了很长的时间,报告说上面的代码执行了超过100,000条机器指令.开什么玩笑,仅仅一行printf就..? 搞什么鬼啊? 答案很值得讨论.Linux下gcc默认将程序动态链接到C运行库,这意味着,当一个程序被运行时,发生的第一件事就是动态库装载器(dynamic library loader)搜索共享库(shared libraries)。这的确需要很多代码。。。并且记住我们的这个简单的tracer会跟踪程序的每一条指令，而不是仅仅main函数。&lt;/p&gt;

&lt;p&gt;如果用-static标志编译代码,让它静态链接(这时候可执行文件大小超过了500KB),这时跟踪程序报告说样例执行的机器指令只有大概7,000条.还是有点多,但是考虑到在main之前libc的初始化,还有main退出后的清理工作,这也就说得过去了.再说了,printf也挺复杂的.&lt;/p&gt;

&lt;p&gt;但是我还是不满意,我想要的是可验证的程序,也就是说,程序执行的整个过程我都一清二楚.所以我写了一个汇编版本的”Hello, world!”:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;section    .text  
    ; The _start symbol must be declared for the linker (ld)
    global _start

_start:

    ; Prepare arguments for the sys_write system call:
    ;   - eax: system call number (sys_write)
    ;   - ebx: file descriptor (stdout)
    ;   - ecx: pointer to string
    ;   - edx: string length
    mov    edx, len
    mov    ecx, msg
    mov    ebx, 1
    mov    eax, 4

    ; Execute the sys_write system call
    int    0x80

    ; Execute sys_exit
    mov    eax, 1
    int    0x80

section   .data  
msg db    'Hello, world!', 0xa  
len equ    $ - msg  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟踪进程报告有7条指令被执行,很好,我可以很容易地验证它.&lt;/p&gt;

&lt;p&gt;有了上面的汇编代码,我们看看ptrace的另一个强悍功能吧–它可以用来跟踪进程的状态.这是run_debugger的下一个版本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void run_debugger(pid_t child_pid)  
{
    int wait_status;
    unsigned icounter = 0;
    procmsg("debugger started\n");

    /* Wait for child to stop on its first instruction */
    wait(&amp;amp;wait_status);

    while (WIFSTOPPED(wait_status)) {
        icounter++;
        struct user_regs_struct regs;
        ptrace(PTRACE_GETREGS, child_pid, 0, &amp;amp;regs);
        unsigned instr = ptrace(PTRACE_PEEKTEXT, child_pid, regs.eip, 0);

        procmsg("icounter = %u.  EIP = 0x%08x.  instr = 0x%08x\n",
                    icounter, regs.eip, instr);

        /* Make the child execute another instruction */
        if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) &amp;lt; 0) {
            perror("ptrace");
            return;
        }

        /* Wait for child to stop on its next instruction */
        wait(&amp;amp;wait_status);
    }

    procmsg("the child executed %u instructions\n", icounter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唯一的不同是&lt;code&gt;while&lt;/code&gt;循环的前面几条代码.有两条&lt;code&gt;ptrace&lt;/code&gt;语句,第一条读取被跟踪进程的寄存器,保存到数据结构user&lt;em&gt;regs&lt;/em&gt;struct(参考sys/user.h)中. 这个头文件顶部的一些注释相当搞笑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* The whole purpose of this file is for GDB and GDB only.
   Don't read too much into it. Don't use it for
   anything other than GDB unless know what you are
   doing.  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个之后，我不知道你怎么想的，我反正觉得我走在正确的大道上了：）。说回demo，一旦在获得了所有寄存器的值后,我们就可以用PTRACE_PEEKTEXT读取eip(extended instruction pointer on x86)对应的机器指令. 现在我们得到的就是机器指令。看一下用我们汇编代码跑在这个tracer里后的输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ simple_tracer traced_helloworld
[5700] debugger started
[5701] target started. will run 'traced_helloworld'
[5700] icounter = 1.  EIP = 0x08048080.  instr = 0x00000eba
[5700] icounter = 2.  EIP = 0x08048085.  instr = 0x0490a0b9
[5700] icounter = 3.  EIP = 0x0804808a.  instr = 0x000001bb
[5700] icounter = 4.  EIP = 0x0804808f.  instr = 0x000004b8
[5700] icounter = 5.  EIP = 0x08048094.  instr = 0x01b880cd
Hello, world!  
[5700] icounter = 6.  EIP = 0x08048096.  instr = 0x000001b8
[5700] icounter = 7.  EIP = 0x0804809b.  instr = 0x000080cd
[5700] the child executed 7 instructions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK,现在除了icounter,我们还能看到eip和它对应的机器指令.怎样验证结果对不对呢? 我们可以借助&lt;code&gt;objdump -d&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ objdump -d traced_helloworld

traced_helloworld:     file format elf32-i386


Disassembly of section .text:

08048080 &amp;lt;.text&amp;gt;:  
 8048080:     ba 0e 00 00 00          mov    $0xe,%edx
 8048085:     b9 a0 90 04 08          mov    $0x80490a0,%ecx
 804808a:     bb 01 00 00 00          mov    $0x1,%ebx
 804808f:     b8 04 00 00 00          mov    $0x4,%eax
 8048094:     cd 80                   int    $0x80
 8048096:     b8 01 00 00 00          mov    $0x1,%eax
 804809b:     cd 80                   int    $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以很容易的把这个结果和我们的输出进行比较&lt;/p&gt;

&lt;h4 id="attachingtoarunningprocess"&gt;Attaching to a running process&lt;/h4&gt;

&lt;p&gt;正如你知道的那样调试器还可以调试正在运行的进程.不出乎意料的,这也是用PTRACE_ATTACH请求来实现.我不再给出代码了,因为在看过我们已经写的代码后，就知道这不难编写.出于教学目的这里选择了比较容易的方法（毕竟我们可以在子进程一开始就暂停子进程）。&lt;/p&gt;

&lt;h4 id="thecode"&gt;The code&lt;/h4&gt;

&lt;p&gt;完整的代码在&lt;a href="https://github.com/eliben/code-for-blog/blob/master/2011/simple_tracer.c"&gt;这里&lt;/a&gt;
. 用gcc -Wall -pedantic –std=c99 code.c编译它(gcc 版本4.4）&lt;/p&gt;

&lt;h4 id="conclusionandnextsteps"&gt;Conclusion and next steps&lt;/h4&gt;

&lt;p&gt;我承认,这篇文章覆盖的内容不多 -– 离真正可以工作的调试器还差得很远.不管怎么样,我希望至少现在看来,调试器没有那么神秘了.ptrace很好很强大,我们刚上路呢.&lt;/p&gt;

&lt;p&gt;在C代码中单步执行确实很有用,但只是某种程度上.以C版本的”Hello, world!”为例,在执行main函数之前,程序已经单步执行了上万条用于C库初始化的机器指令了,可以看出,这很不方便.我们的需求其实是在main入口前面放置断点,然后break到main函数.在part2里面我打算告诉大家breakpoint是如何实现的.&lt;/p&gt;</content:encoded></item><item><title>ReactiveCocoa的架构设计</title><description>&lt;p&gt;简单学习一下ReactiveCocoa的架构设计, 目前找不到一个很好的中文翻译，所以这里就试着翻译一下&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id="event"&gt;Event&lt;/h2&gt;

&lt;p&gt;一个 event 代表着某个事情发生了，比如说按了一个 button ，收到了一个网络请求，某个错误发生了等等。event 可以通过 signal 来发送给每一个 observer. 我们用 &lt;code&gt;Event&lt;/code&gt; 类型来描述一个 event 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Event&lt;/code&gt; 是一个 Enum 类型，它或者代表一个值，或者代表后面事件之一&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Next&lt;/code&gt; event 表示有新值到来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed&lt;/code&gt; event 表示在 signal 结束之前有错误发生。具体是什么类型的错误，可以通过 &lt;code&gt;Event&lt;/code&gt; 里面的 &lt;code&gt;ErrorType&lt;/code&gt; 来获知。 但是如果根本不允许出现错误， 可以制定错误类型为 &lt;code&gt;NoError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Completed&lt;/code&gt; event 表示 signal 已经结束，不会有新值来了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupted&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>http://localhost:2368/reactivecocoade-jia-gou-she-ji/</link><guid isPermaLink="false">012007db-c51a-4af3-9bdc-7bb6ecd48b85</guid><category>ReactiveCocoa</category><category>Architecture</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 08:20:59 GMT</pubDate><content:encoded>&lt;p&gt;简单学习一下ReactiveCocoa的架构设计, 目前找不到一个很好的中文翻译，所以这里就试着翻译一下&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id="event"&gt;Event&lt;/h2&gt;

&lt;p&gt;一个 event 代表着某个事情发生了，比如说按了一个 button ，收到了一个网络请求，某个错误发生了等等。event 可以通过 signal 来发送给每一个 observer. 我们用 &lt;code&gt;Event&lt;/code&gt; 类型来描述一个 event 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Event&lt;/code&gt; 是一个 Enum 类型，它或者代表一个值，或者代表后面事件之一&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Next&lt;/code&gt; event 表示有新值到来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed&lt;/code&gt; event 表示在 signal 结束之前有错误发生。具体是什么类型的错误，可以通过 &lt;code&gt;Event&lt;/code&gt; 里面的 &lt;code&gt;ErrorType&lt;/code&gt; 来获知。 但是如果根本不允许出现错误， 可以制定错误类型为 &lt;code&gt;NoError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Completed&lt;/code&gt; event 表示 signal 已经结束，不会有新值来了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupted&lt;/code&gt; event` 表示 signal 表示操作被 cancel 了，结果既不是成功也不是失败&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="signals"&gt;Signals&lt;/h2&gt;

&lt;p&gt;一系列的 event 就组成了 signal, signal 是可以被观察的&lt;/p&gt;

&lt;p&gt;信号通常代表着 in progress 的事件流，比如说 notifications, user input 等。当收到新数据，或者任务完成的时候，event 会通过 signal 
里同时推送到每一个观察者那里。&lt;/p&gt;

&lt;p&gt;如果想要接收到某个 signal 的 event , 就必须观察这个 signal。 观察一个 signal 并不会有任何副作用。 也就是说，signal 是完全的基于生产者驱动以及推送的，消费者（observers）对自己的生命周期没有任何控制权。当观察一个 signal 时，用户仅仅能对发送过来的 event 按照发送的顺序进行处理。不存在随机访问这些值的办法。&lt;/p&gt;

&lt;p&gt;可以通过使用基础操作符来操作 signal。包括 &lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;reduce&lt;/code&gt;，还有一次性处理多个 signal 的 &lt;code&gt;zip&lt;/code&gt;。这些基础操作仅仅作用于对 &lt;code&gt;Next&lt;/code&gt; 事件&lt;/p&gt;

&lt;p&gt;signal 的生命周期由任意数量的 &lt;code&gt;Next&lt;/code&gt; 事件和一个结束 event 组成。结束事件可以是 &lt;code&gt;Failed&lt;/code&gt;，或&lt;code&gt;Completed&lt;/code&gt;，或&lt;code&gt;Interrupted&lt;/code&gt;。signal 发送的值不包括结束 event，他们必须被单独处理。&lt;/p&gt;

&lt;h2 id="pipes"&gt;Pipes&lt;/h2&gt;

&lt;p&gt;pipe 是一个可以人工控制的 signal，它由 &lt;code&gt;Signal.pipe()&lt;/code&gt; 方法创建的。&lt;/p&gt;

&lt;p&gt;这个方法返回一个 signal 和一个 observer. 发送给观察者的事件是受控制的。这个在把 non-RAC 的代码转换成 signal 的世界时是非常有用的。&lt;/p&gt;

&lt;p&gt;举个例子，我们可以简单的通过 signal 给观察者发送 event，来替代以前使用的 callback。 同时 signal 可以返回，这样就隐藏了 callback 的细节。&lt;/p&gt;

&lt;h2 id="signalproducers"&gt;Signal Producers&lt;/h2&gt;

&lt;p&gt;signal producer, 可以创建 signal 并且引起一些副作用， 我们用 &lt;code&gt;SignalProducer&lt;/code&gt; 来表示。&lt;/p&gt;

&lt;p&gt;signal producer 可以用来代表一系列操作或者任务，比如网络请求。每次调用 &lt;code&gt;start()&lt;/code&gt; 都会引起一个相关的操作，并且使得调用者观察结果。&lt;code&gt;startWithSignal()&lt;/code&gt; 返回出产生的信号，使得多次观察比较方便。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;start()&lt;/code&gt; 的不同行为，每个从同一个 signal producer 产生的 signal 都可能产生不同顺序不同版本的 event。这是和普通的 signal 不同的地方。&lt;/p&gt;

&lt;p&gt;启动一个 signal producer 会得到一个 disposable，它可以用来 &lt;code&gt;interrupt/cancel&lt;/code&gt; 相关的 signal&lt;/p&gt;

&lt;p&gt;signal producers 也可以被基础操作符操作，比如 &lt;code&gt;map&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;。除此之外，它还可以被 &lt;code&gt;lift&lt;/code&gt;。或者是用 &lt;code&gt;time&lt;/code&gt; 来控制何时 &lt;code&gt;start&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id="buffers"&gt;Buffers&lt;/h2&gt;

&lt;p&gt;buffer 保存了一系列 events，当有新的 signal 从 signal producer 里创建的时候，它可以重现这些 event。RAC 用 &lt;code&gt;SignalProducer.buffer()&lt;/code&gt; 来创建 buffer。 buffer 是有大小的，满了以后，会自动顶出最先进入的 event。&lt;/p&gt;

&lt;h2 id="observers"&gt;Observers&lt;/h2&gt;

&lt;p&gt;RAC 使用 &lt;code&gt;Observer&lt;/code&gt; 来表示 observer，显然它可以接收 event 的值&lt;/p&gt;

&lt;p&gt;observer 可以隐含的被创建，比如说被基于 callback 的 &lt;code&gt;Signal.observe&lt;/code&gt; 或者 &lt;code&gt;SignalProducer.start&lt;/code&gt; 方法&lt;/p&gt;

&lt;h2 id="actions"&gt;Actions&lt;/h2&gt;

&lt;p&gt;一个 action 可以在输入发生的时候执行某些工作。我们用 &lt;code&gt;Action&lt;/code&gt; 类型来表示一个 action。 当 action 执行的时候，可能产生一个，多个输出值，也可能产生失败事件。&lt;/p&gt;

&lt;p&gt;action 非常适合用来执行某个用户操作（比如点击一个button）的副作用。action 也可以根据一个属性自动的 enable/disable ，并且这种 diable 状态还可以和相关联的 UI 控件的 enable/disable 状态绑定。&lt;/p&gt;

&lt;p&gt;对于 UIControl 或者 NSControl 来说，RAC 也提供了 CocoaAction 与之对应。 &lt;/p&gt;

&lt;h2 id="properties"&gt;Properties&lt;/h2&gt;

&lt;p&gt;用 &lt;code&gt;PropertyType&lt;/code&gt; 协议表示的 property, 它保存着一个值，并且可以在值变化的时候通知 observer&lt;/p&gt;

&lt;p&gt;property 的当前值可以使用 &lt;code&gt;value&lt;/code&gt; 这个 getter 来获得. 另外的一个叫做 &lt;code&gt;producter&lt;/code&gt; 的 getter 会返回一个 signal producer ，它会发送这个属性的当前值，并且以后任何变化也都会被推送&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt; 操作符可以用来绑定属性。需要注意，目标一定得是 &lt;code&gt;MutablePropertyType&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;property &amp;lt;~ signal&lt;/code&gt; 把一个 signal 绑定到 property上，property的值会根据 signal 发送的新值而变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property &amp;lt;~ producer&lt;/code&gt; 启动这个绑定的 producer，并且根据新发送的值而改变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property &amp;lt;~ otherProperty&lt;/code&gt; 绑定另一个 property 到本 property 这样本 property 就会睡着 otherProperty 而变化了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;DynamicProperty&lt;/code&gt; 类型可以用来桥接以前的 Objective－c API，比如KVC 或者 KVO, 像 NSOperation 之类的. 注意，始终应该优先考虑使用&lt;code&gt;MutableProperty&lt;/code&gt; 而不是 dynamic property !&lt;/p&gt;

&lt;h2 id="disposables"&gt;Disposables&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;Disposable&lt;/code&gt; 协议表示的 &lt;code&gt;disposable&lt;/code&gt;, 是一种内存管理和取消的机制&lt;/p&gt;

&lt;p&gt;每当启动一次 signal producer, 都会返回一个 disposable . 它可以被调用者用来取消已经启动的工作(比如 后台处理或者网络请求等), 清理所有的临时的资源，然后发送 &lt;code&gt;Interrupted&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;观察一个 signal 也许也会产生 disposable. 丢弃它可以阻止 observer 继续接收未来的 event , 但是它不会对 signal 自身有任何影响.&lt;/p&gt;

&lt;h2 id="schedulers"&gt;Schedulers&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;SchedulerType&lt;/code&gt; 协议表示的 scheduler 是一个工作队列，上面执行着发布到它上面的任务&lt;/p&gt;

&lt;p&gt;signal 和 signal producer 可以指定它们发送 event 的 scheduler. signal producer 还可以指定它的工作在哪个 scheduler 里启动.&lt;/p&gt;

&lt;p&gt;scheduler 和 Grand Central Dispatch 队列类似, 但是 scheduler 支持取消 (通过 disposable), 并且永远是顺序执行. 除了 &lt;code&gt;ImmediateScheduler&lt;/code&gt;, scheduler 不支持同步执行. 这有助于避免死锁，鼓励使用操作符而不是 block 来工作&lt;/p&gt;

&lt;p&gt;scheduler 更像 NSOperationQueue, 但是 schedulers 不允许重置任务顺序或者任务有依赖关系.&lt;/p&gt;</content:encoded></item><item><title>ReactiveCocoa和MVVM简介</title><description>&lt;p&gt;本文主要翻译自&lt;a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/"&gt;原文&lt;/a&gt;, 不过省去了大段啰嗦，并且也加入了其他的一些观点。&lt;/p&gt;

&lt;p&gt;MVC模式有一个非常让人头疼的问题就是controller往往过于庞大。&lt;code&gt;MVVM&lt;/code&gt;是解决的方法之一。&lt;/p&gt;

&lt;h3 id="mvvm"&gt;MVVM的三个结论&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;可以兼容当下使用的&lt;code&gt;MVC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;可以增加应用的可测试新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;配合绑定机制效果最好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="mvvm"&gt;什么是MVVM&lt;/h3&gt;

&lt;!--more--&gt;

&lt;p&gt;与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvvm1.png" alt="MVC Architecture"&gt;&lt;/p&gt;

&lt;p&gt;我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。Cool！&lt;/p&gt;

&lt;p&gt;稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，&lt;strong&gt;但它们几乎总是手牵手在一起，成对的&lt;/strong&gt;。你什么时候看到一个 View 能够与不同 View Controller&lt;/p&gt;</description><link>http://localhost:2368/reactivecocoahe-mvvmjian-jie/</link><guid isPermaLink="false">26019261-37fa-4594-b491-1994795bbe35</guid><category>iOS</category><category>ReactiveCocoa</category><category>Architecture</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:54:30 GMT</pubDate><content:encoded>&lt;p&gt;本文主要翻译自&lt;a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/"&gt;原文&lt;/a&gt;, 不过省去了大段啰嗦，并且也加入了其他的一些观点。&lt;/p&gt;

&lt;p&gt;MVC模式有一个非常让人头疼的问题就是controller往往过于庞大。&lt;code&gt;MVVM&lt;/code&gt;是解决的方法之一。&lt;/p&gt;

&lt;h3 id="mvvm"&gt;MVVM的三个结论&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;可以兼容当下使用的&lt;code&gt;MVC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;可以增加应用的可测试新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;配合绑定机制效果最好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="mvvm"&gt;什么是MVVM&lt;/h3&gt;

&lt;!--more--&gt;

&lt;p&gt;与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvvm1.png" alt="MVC Architecture"&gt;&lt;/p&gt;

&lt;p&gt;我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。Cool！&lt;/p&gt;

&lt;p&gt;稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，&lt;strong&gt;但它们几乎总是手牵手在一起，成对的&lt;/strong&gt;。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvvm2.png" alt="vcm"&gt;&lt;/p&gt;

&lt;p&gt;这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级 View Controller 的问题。在典型的 MVC 应用里，许多逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 NSDate 转换为一个格式化过的 NSString。&lt;/p&gt;

&lt;p&gt;我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvvm3.png" alt="vcvmm"&gt;&lt;/p&gt;

&lt;p&gt;看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了 View 和 Controller ，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。&lt;/p&gt;

&lt;p&gt;下图显示了整个变化的过程&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvmcv.gif" alt="mvmcv"&gt;&lt;/p&gt;

&lt;p&gt;现在 View Controller 仅关注于用 view-model 的数据配置和管理各种各样的 View , 并在先关用户输入时让 view-model 获知并需要向上游修改数据.  View Controller 不需要了解关于网络服务调用, Core Data, 模型对象等. &lt;/p&gt;

&lt;p&gt;view-model 会在 View Controller 上&lt;em&gt;以一个属性的方式存在&lt;/em&gt;.  View Controller 知道 view-model 和它的公有属性, 但是 view-model 对 View Controller 一无所知. 你该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离. &lt;br&gt;
为了更好的理解如何把这些组件组装在一起，以及每个组件对应职责，我们可以看看新的应用架构的模块层级图.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-mvvm-layers.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="viewmodelviewcontroller"&gt;ViewModel 和 ViewController 在一起，但独立&lt;/h3&gt;

&lt;p&gt;我们来看个简单的 view-model 头文件，这样可以对我们的新组件 ViewModel 有一个直观印象。我们举一个简单的例子, 假设我们在制作一个推特的客户端，通过在输入框里，输入他们的姓名并点击 “Go”，它可以用来查看任何推特用户的最新回复。&lt;/p&gt;

&lt;p&gt;我们的例子的界面将会是这样:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有一个让用户输入他们姓名的 UITextField , 和一个写着 “Go” 的 UIButton&lt;/li&gt;
&lt;li&gt;有显示被查看的当前用户头像和姓名的 UIImageView 和 UILabel 各一个&lt;/li&gt;
&lt;li&gt;下面放着一个显示最新回复推文的 UITableView&lt;/li&gt;
&lt;li&gt;允许无限滚动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-23-tweeboatplus.svg" style="width: 320px;"&gt;&lt;/p&gt;

&lt;h3 id="viewmodel"&gt;ViewModel的例子&lt;/h3&gt;

&lt;script src="https://gist.github.com/IamAlchemist/8193de9995d7f9bd88cd.js"&gt;&lt;/script&gt;

&lt;p&gt;注意到这些 readonly 属性了么?这个 view-model 暴漏了 View Controller 所必需的最小量信息,  View Controller 实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;view-model 没有做的事儿&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对 View Controller 直接操作或直接通告其变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="viewcontroller"&gt;View Controller&lt;/h3&gt;

&lt;p&gt;View Controller 从 view-model 获取的数据将用来:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当 usernameValid 的值发生变化时改变 “Go” 按钮的 enabled 属性&lt;/li&gt;
&lt;li&gt;当 usernameValid 等于 NO 时调整按钮的 alpha 值为0.5(等于 YES 时设为1.0)&lt;/li&gt;
&lt;li&gt;更新 UILable 的 text 属性为字符串 userFullName 的值&lt;/li&gt;
&lt;li&gt;更新 UIImageView 的 image 属性为 userAvatarImage 的值&lt;/li&gt;
&lt;li&gt;用 tweets 数组中的对象设置tableview 中的 cell &lt;/li&gt;
&lt;li&gt;当滑到tableview底部时如果 allTweetsLoaded 为 NO, 提供一个 显示 “loading” 的 cell&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;View Controller 将对 view-model 做如下操作:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username&lt;/li&gt;
&lt;li&gt;当 “Go” 按钮被按下时调用 view-model 上的 getTweetsForCurrentUsername 方法&lt;/li&gt;
&lt;li&gt;当滚动到 “loading” cell 时调用 view-model 上的 loadMoreTweets 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;View Controller 不做的事儿:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发起网络服务调用&lt;/li&gt;
&lt;li&gt;管理 tweets 数组&lt;/li&gt;
&lt;li&gt;判定 username 内容是否有效&lt;/li&gt;
&lt;li&gt;将用户的姓和名格式化为全名&lt;/li&gt;
&lt;li&gt;下载用户头像并转成 UIImage &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请再次注意 View Controller 总的责任是处理 view-model 中的变化&lt;/p&gt;

&lt;h3 id="viewmodel"&gt;子 View-Model&lt;/h3&gt;

&lt;p&gt;view-model 不必包括在屏幕上显示所有东西. 可用子 view-model 来代表屏幕上更小, 并且有必要封装的部分. 比如tableview 的 cell 在 app 中可以被重用, 那么子 view-model 就会格外有利.&lt;/p&gt;

&lt;p&gt;在我们的例子中, tweets 数组将会包含下面这样的子 view-model :&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/9eb9ad7c28fca4fd22b4.js"&gt;&lt;/script&gt;

&lt;h3 id="viewmodel"&gt;View-Model 从哪来?&lt;/h3&gt;

&lt;p&gt;view-model 是何时何处被创建的呢? 是 View Controller 创建它们自己的 view-model 么?&lt;/p&gt;

&lt;h4 id="viewmodelviewmodel"&gt;View-Model 产生 View-Model&lt;/h4&gt;

&lt;p&gt;严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-16-14-24.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;比如说，我们想要在用户点击应用顶部的头像时添加一个个人资料的 View Controller . 我们可以为一级的 view-model 添加类似如下方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向下面这样使用&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/81d217a606c0433d28aa.js"&gt;&lt;/script&gt;

&lt;p&gt;这个例子中当我们展现当前用户的资料 VC 时, 这个新的 VC 需要一个 view-model. 而当前的 VC 不知道(也不该知道)用于创建相关用户 view-model 的全部数据, 所以它请求它自己的 view-model 来创建新的 view-model .&lt;/p&gt;

&lt;h4 id="viewmodel"&gt;View-Model 列表&lt;/h4&gt;

&lt;p&gt;至于 tableview 的 cell, 当获得到新的数据时(或许是通过网络), 我们会一次性的为对应的所有 cell 创建所有的 view-model. 所以, tweets 是一个 MYTweetCellViewModel 对象数组. 在 tableview 的 cellForRowAtIndexPath 方法中, 我们会取得正确的 view-model, 并把它赋值给对应的 cell 上的 view-model 属性.&lt;/p&gt;

&lt;h3 id=""&gt;可测试&lt;/h3&gt;

&lt;p&gt;函数式编程的好处之一就是每一个函数是没有状态的，同样的输入对应的同样的输出。因此也是极度好测试的。&lt;/p&gt;

&lt;p&gt;事实上，我们也可以使 view-model 尽可能的达到无状态的程度。其实这也比较符合 view-model 的本意，view-model 被设计用来把数据模型转变成 view 显示需要的属性。理想上相同的输入(比如网络服务响应)将会导出相同的输出(属性的值).&lt;/p&gt;

&lt;p&gt;所以好的 view-model 可以是非常容易进行单元测试的. &lt;/p&gt;

&lt;h3 id=""&gt;绑定&lt;/h3&gt;

&lt;p&gt;当初始化 VC 的时候，我们往往可以根据 view-model 的属性来显示 View，但是当 view-model 的属性发生变化时我们如何更新我们的 View 呢?&lt;/p&gt;

&lt;p&gt;可以的选择大概有这些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将 VC 暴露给 view-model, 以便于当相关数据变化或类似事件发送时它可以调用一个 “updateUI” 方法. (完全破坏了封装)&lt;/li&gt;
&lt;li&gt;在 view-model 里将 VC 作为一个委托, 当 view-model 内容有变化时发个通知 (好一些，一半封装，如果有大量的独立变化的属性感觉就要抓狂了)&lt;/li&gt;
&lt;li&gt;KVO （挺好，不过api过度设计，很难用，不支持block）&lt;/li&gt;
&lt;li&gt;ReactiveCocoa (api很好用，并且可以用响应式编程的方式来思考)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="reactivecocoadelegatenotification"&gt;ReactiveCocoa 和 delegate, notification 等的区别是什么？&lt;/h3&gt;

&lt;p&gt;拿一个输入用户名和密码的例子来说, 当输入合法时, 我们需要更新提交按钮的状态. 按通常的编程范式，很可能会照下面这么做:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-17-59-34.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到，每一条简单的逻辑里都分布了许多零碎的需要考虑状态的代码。尽管封装了 updateSubmitButtonStatus 这样的函数，但是这个函数里面判断状态的代码由于要考虑使用的上下文关系，也复杂得让可读性基本上降为了0。有经验的人知道维护这样的代码有多头疼。注意，这还只是一个 UI 元素中的一条逻辑线。。。。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来看一下下面这个版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-17-59-56.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;这看起来可能像是为我们流程文档中的一张旧式的插图. 但是通过这样声明, 我们事实上使用了更高层次的抽象, 这让我们在实际编程可以更接近我们在脑海中流程的设计方式. 这种方式下，计算机为我们做更多工作. 而实际的代码也更加像这幅图了.&lt;/p&gt;

&lt;h3 id="racsignal"&gt;RACSignal&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;RACSignal&lt;/code&gt; 是 RAC 的构造单元. 它代表最终将要收到的信息. 当你能将未来某时刻收到的消息具体表示出来时, &lt;strong&gt;你就可以开始运用逻辑构建信息流(声明式), 而不是必须等到事件发生(驱动式)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RACSignal&lt;/code&gt;控制这些信息流使用了下面所有的这些异步方法(delegates, callback blocks, notifications, KVO, target/action event observers 等)，并将它们统一到一个好用的接口下. 这只是简单直观解释. 其实它提供的功能不仅是这些, 因为它还提供给你轻松转换/分解/合并/过滤信号的能力.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-19-25-46.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="signal"&gt;那么什么是Signal&lt;/h3&gt;

&lt;p&gt;这是一个信号:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-19-28-36.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Signal 是一个发送一连串值(Event)的 object . 但目前这个 Signal 啥也不干, 因为它还没有 Subscriber. Signal 只有在有 Subscriber 监听时，Signal 才会发信息. 它将会向 Subscriber 发送0或多个载有数值的&lt;code&gt;next&lt;/code&gt;事件, 后面跟着一个&lt;code&gt;complete&lt;/code&gt;事件或一个&lt;code&gt;error&lt;/code&gt;事件. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-19-35-24.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;正如之前提到的, 如果觉得需要的话, 你可以过滤, 转换, 分解和合并那些值. 不同的订阅者可能需要使用Signal通过不同方式发送的值. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-19-36-56.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id=""&gt;从哪获得信号发送的值?&lt;/h3&gt;

&lt;p&gt;信号异步的等待某事发生, 然后把结果值发送给它们的订阅者. 你可以用 &lt;code&gt;RACSignal&lt;/code&gt; 的类方法 &lt;code&gt;createSignal:&lt;/code&gt; 手动创建信号:&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/8b198f1ab4e94a28e317.js"&gt;&lt;/script&gt;

&lt;p&gt;这里使用了一个网络操作来创建了一个 Signal . 这个网络操作成功以后，它会给 subscriber 发送&lt;code&gt;sendNext:&lt;/code&gt; 和 &lt;code&gt;sendCompleted:&lt;/code&gt; 事件. 如果失败， 会触发一个 &lt;code&gt;sendError:&lt;/code&gt; 事件。 现在就可以 subscribe 这个 signal 了。&lt;/p&gt;

&lt;p&gt;事实上这样创建的Signal并不常见，RAC 提供了很多机制, 来从我们常用的异步模式中拉取信号. 即使有一些异步模式 RAC 没有直接提供，也可以用&lt;code&gt;createSignal:&lt;/code&gt;很容易的创建&lt;/p&gt;

&lt;p&gt;RAC 其中提供的一个机制就是 &lt;code&gt;RACObserve()&lt;/code&gt; 宏. 这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, &lt;code&gt;RACObserve&lt;/code&gt; 会创建一个信号, 一旦它有了 subscriber , 它就立刻发送那个属性的当前值, 这个属性在这之后的任何变化也会被发送.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *usernameValidSignal = RACObserve(self.viewModel, usernameIsValid);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://www.sprynthesis.com/assets/images/signal-racobserve.svg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;这仅是提供用于创建信号工具的其中一个. 下面有几个立即可用的方式, 来从内置控制流机制中产生信号:&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/6aa39320560bd1749ca1.js"&gt;&lt;/script&gt;

&lt;p&gt;你也能很容易的创建自己的信号, 包括替代那些没有 RAC 支持的其他委托. 我们现在能够从所有这些不连贯的异步/控制流工具中拉取出信号并将他们合并, 试想想这些会成为我们之前看到的声明式图表中的节点. Nice！！！&lt;/p&gt;

&lt;h3 id="subscriber"&gt;什么是 subscriber ?&lt;/h3&gt;

&lt;p&gt;简言之, subscriber 就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 &lt;code&gt;“complete”&lt;/code&gt; 和 &lt;code&gt;“error”&lt;/code&gt; 事件. )&lt;/p&gt;

&lt;p&gt;来看一个简单的 subscriber , 它是通过向 signal 的方法 &lt;code&gt;subscribeNext&lt;/code&gt; 传入一个 block 来创建的. 这里通过 RACObserve() 宏创建信号来观察一个对象上属性的值, 并把它赋值给一个内部属性. &lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/e70e861b00c54d250e48.js"&gt;&lt;/script&gt;

&lt;p&gt;BTW：RAC 只处理对象, 而不处理像 BOOL 这样的基本类型值. 不过不用担心, RAC 通常会帮你做转换.&lt;/p&gt;

&lt;p&gt;上面的代码看起来有点冗余。 RAC 也意识到这种赋值绑定的普遍, 所以它提供了另一个宏 RAC(). 与 RACObserve() 相同, 你提供想要与即将到来的值绑定的对象和参数, 它内部就会像上面代码一样，创建一个订阅者并更新绑定的属性的值. 这个例子现在看起来像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) viewDidLoad {
    //...
    RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑下我们的目标, 这么干其实有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI .&lt;/p&gt;

&lt;h3 id=""&gt;转换数据流&lt;/h3&gt;

&lt;p&gt;现在我们使用 RAC 提供的用于转换数值流的方法. 我们将会利用 RACSignal 的实例方法 map.&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/3742afcded5793ca2e22.js"&gt;&lt;/script&gt;

&lt;p&gt;这样现在我们将 view-model 上的 isUsernameValid 发生的变化直接绑定到 goButton 的 enabled 属性上. 酷吧? 对 alpha 的绑定更酷, 因为我们正在使用 map 方法将值转换成与 alpha 属性相关的值. (注意在这里我们返回的是一个 NSNumber 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来.)&lt;/p&gt;

&lt;h3 id=""&gt;多个订阅者, 副作用, 代价&lt;/h3&gt;

&lt;p&gt;这里需要指出的是，当信号需要发送一个新的值时, 它会遍历所有的订阅者并给每个订阅者发送那个值. 对我们而言，信号发出的值不存储在任何地方(除了 RAC 在内部实现中). 也就是说每当一个新值通过信号链被发送出去时, 实际上会给每个订阅者都发送一次. &lt;/p&gt;

&lt;p&gt;这意味着信号链某处存在的任何副作用, 任何影响 App 状态的转变, 将会发生多次. 这对新接触 RAC 的用户来说往往是意想不到的. (这也违反了函数式编程的理念-单纯的数据输入, 数据输出).&lt;/p&gt;

&lt;p&gt;一个做作的例子可能是: 信号链某处的信号在每次按钮被按下时更新 &lt;code&gt;self&lt;/code&gt; 中的一个计数器属性. 如果信号链有多个订阅者, 计数器的增长将会比你想的还要多. 你需要努力从信号链中尽可能剔除副作用. 当副作用不可避免时, 你可以使用一些恰当的预防机制. 就不再这里多说了。&lt;/p&gt;

&lt;p&gt;除副作用之外, 还需要注意带有昂贵操作和可变数据的信号链. 网络请求就是一个三者兼得的例子:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络请求影响了应用的网络层(副作用).&lt;/li&gt;
&lt;li&gt;网络请求为信号链引入了可变数据. (两个完全一样请求可能返回了不同的数据. )&lt;/li&gt;
&lt;li&gt;网络请求反应慢啊.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如, 你可能有个信号在每次按钮按下时发送一个值, 而你想将这个值转换成网络请求的结果. 如果有多个订阅者要这个处理信号链上返回的这个值, 你将发起多个网络请求.(有点诡异！)&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/Screen-Shot-2015-11-24-at-22-12-34.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;网络请求明显是经常需要的. 正如你所期望, RAC 提供这些情况的解决方案, 也就是 &lt;code&gt;RACCommand&lt;/code&gt; 和多点广播. 我将会在下一篇文章中更深入地分析.&lt;/p&gt;

&lt;h2 id="reactivecocoamvvm"&gt;Reactivecocoa + MVVM&lt;/h2&gt;

&lt;p&gt;简短的介绍(嗯哼)有点扯远了, 现在我们看看如何用 ReactiveCocoa 将 view-model 与视图控制器连接起来.&lt;/p&gt;

&lt;script src="https://gist.github.com/IamAlchemist/92d543effd1e57a34ded.js"&gt;&lt;/script&gt;

&lt;p&gt;让我们过一遍这个例子.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RAC(self.viewModel,  username) = [myTextfield rac_textSignal];  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这我们用 RAC 库中的方法从 &lt;code&gt;UITextField&lt;/code&gt; 拉取一个信号. 这行代码将 view-model 上的可读写属性 username 绑定到文本框上的用户输入的任何更新.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RACSignal *usernameIsValidSignal = RACObserve(self.viewModel,  usernameValid);

RAC(self.goButton,  alpha) = [usernameIsValidSignal  
    map:  ^(NSNumber *valid) {
        return valid. boolValue ? @1 :  @0. 5;
    }];

RAC(self.goButton,  enabled) = usernameIsValidSignal;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这我们用 &lt;code&gt;RACObserve&lt;/code&gt; 方法在 view-model 的 usernameValid 属性上创建了一个信号 &lt;code&gt;usernameIsValidSignal&lt;/code&gt;. 无论何时属性发生变化, 它将会沿着管道发送一个新的 &lt;code&gt;YES&lt;/code&gt; 或 &lt;code&gt;NO&lt;/code&gt;. 我们拿到那个值并将其绑定到 goButton 的两个属性上. 首先我们将 alpha 分别对应 &lt;code&gt;YES&lt;/code&gt; 或 &lt;code&gt;NO&lt;/code&gt; 更新到1或0. 5(记着在这必须返回 NSNumber). 然后我们直接将信号绑定到 enabled 属性, 因为 &lt;code&gt;YES&lt;/code&gt; 和 &lt;code&gt;NO&lt;/code&gt; 在这无需转换就能完美地运作.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RAC(self.avatarImageView,  image) = RACObserve(self.viewModel,  userAvatarImage);

RAC(self.userNameLabel,  text) = RACObserve(self.viewModel,  userFullName);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们为 tableview 的 header 的 imageview 和用户标签创建绑定, 再次在 view-model 上对应的属性上用 RACObserve 宏创建信号.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@weakify(self);
[[[RACSignal merge:@[RACObserve(self.viewModel, tweets),
                     RACObserve(self.viewModel, allTweetsLoaded)]]
    bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]
    subscribeNext:^(id value) {
        @strongify(self);
        [self.tableView reloadData];
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这货看上去有点诡异, 所以我们在这上多花点时间. 我们想在 view-model 上 tweets 数组或 allTweetsLoaded 属性发生变化时更新表格视图. (在这个例子中, 我们要用一个简单的方法来重新加载整张表. )所以我们将这两个属性被观察后创建的两个信号合并成一个更大的信号, 当两个属性中有一个发生变化, 这个信号就会发送值.&lt;/p&gt;

&lt;p&gt;那么这儿看起来最吓人的部分可能是信号链中的 &lt;code&gt;bufferWithTime: onScheduler:&lt;/code&gt; 方法. 这是因为需要它来围绕 &lt;code&gt;UIKit&lt;/code&gt; 中的一个问题进行变通. &lt;code&gt;tweets&lt;/code&gt; 和 &lt;code&gt;allTweetsLoaded&lt;/code&gt; 这两个属性我们都需要追踪. 有时两个属性都将在同一时间发生变化, 意味着合并后的大信号中的两个信号都会发送一个值, 那么 &lt;code&gt;reloadData&lt;/code&gt; 方法将会在同一个 &lt;code&gt;run loop&lt;/code&gt; 中被调用两次. &lt;code&gt;UIKit&lt;/code&gt; 不喜欢这样. &lt;code&gt;bufferWithTime:&lt;/code&gt; 在给定的时间内接收所有发送来的值, 然后在给定的时间过后再将所有值合在一起发给订阅者. 通过传入0作为时间, &lt;code&gt;bufferWithTime:&lt;/code&gt; 将会接受再一个&lt;code&gt;run loop&lt;/code&gt;中发出的全部值, 然后再将他们一起发送出去. 暂时不用担心 &lt;code&gt;scheduler&lt;/code&gt;, 试把它想做指明这些值必须在主线程上被发送. 现在我们确保 &lt;code&gt;reloadData&lt;/code&gt; 每次运行循环只被调用一次.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意我在这用 @weakify/@strongify, RAC 中引用 self 时一定要注意循环引用的问题&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]
    subscribeNext: ^(id value) {
        @strongify(self);
        [self.viewModel getTweetsForCurrentUsername];
    }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我将会在下一篇文章中在这里引入 &lt;code&gt;RACCommand&lt;/code&gt;, 但目前我们只是当按钮被触碰时手动调用 view-model 的 &lt;code&gt;getTweetsForCurrentUsername&lt;/code&gt; 方法.&lt;/p&gt;

&lt;p&gt;我们已经搞定了 &lt;code&gt;cellForRowAtIndexPath&lt;/code&gt; 的第一部分, 那么我在这将只说下 loading cell:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYLoadingCell *cell =  
    [self.tableView dequeueReusableCellWithIdentifier:@"MYLoadingCell" forIndexPath:indexPath];
[self.tableView loadMoreTweets];
return cell;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是另一块我们以后将利用到 &lt;code&gt;RACCommand&lt;/code&gt; 的地方, 但目前我们只是调用 view-model 的 loadMoreTweets 方法. 我们这里只是信任如果 cell 显示或隐藏多次的话 view-model 会避免多次内部调用.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) awakeFromNib {
    [super awakeFromNib];

    RAC(self.avatarImageView, image) = RACObserve(self, viewModel.userAvatarImage);
    RAC(self.userNameLabel, text) = RACObserve(self, viewModel.tweetAuthorFullName);
    RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel.tweetContent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们正在将图片和文字绑定到 UI 上对应的属性, 这里我想指出一点. 注意 viewModel 出现在 RACObserve 宏中逗号右边. 这些 cell 终将被重用, viewModel 会被新的 view-model 赋值. 如果我们不将 viewModel 放在逗号右边, 那么每次改变新的viewModel的话，都要重新设置绑定; 如果放在逗号右边, RACObserve 将会为我们负责这些事儿. 因此我们只需要设定一次绑定并让 Reactive Cocoa 做剩余的部分. 这是在绑定 table cell 时为了性能需要记住的好东西. 我在实践中即使是有很多 table cell 依然没有出过问题.&lt;/p&gt;

&lt;h2 id=""&gt;引用&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://objccn.io/issue-13-1/"&gt;MVVM 介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/"&gt;ReactiveCocoa and MVVM, an Introduction&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>理解 Objective-C Runtime</title><description>Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C和汇编写的Runtime库。它负责加载类的信息，分发函数消息。从而使得c可以面向对象，变成了Objective-C。  
Runtime的核心就是消息传递 (Messaging)  
&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. &lt;strong&gt;The big idea is “messaging”&lt;/strong&gt; – that is what the kernal[sic] of Smalltalk is all about.&lt;/p&gt;&lt;/blockquote&gt;</description><link>http://localhost:2368/li-jie-objective-c-runtime/</link><guid isPermaLink="false">86d881c9-f466-4a66-b8f4-39800be51e81</guid><category>Objc</category><category>iOS</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:52:13 GMT</pubDate><content:encoded>Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C和汇编写的Runtime库。它负责加载类的信息，分发函数消息。从而使得c可以面向对象，变成了Objective-C。  
Runtime的核心就是消息传递 (Messaging)  
&lt;!--more--&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. &lt;strong&gt;The big idea is “messaging”&lt;/strong&gt; – that is what the kernal[sic] of Smalltalk is all about... The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;-- by Alan Kay&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在C语言调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C中，&lt;code&gt;[object foo]&lt;/code&gt;语句并不会立即执行&lt;code&gt;foo&lt;/code&gt;这个方法的代码。它是在运行时给&lt;code&gt;object&lt;/code&gt;发送一条叫&lt;code&gt;foo&lt;/code&gt;的消息。这个消息，也许会由&lt;code&gt;object&lt;/code&gt;来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。&lt;/p&gt;

&lt;p&gt;事实上，在编译时Objective-C函数调用的语法都会被翻译成一个C的函数调用 - objc_msgSend(). &lt;br&gt;
比如，编译器会把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[target doMethodWith:var1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objc_msgSend(target,@selector(doMethodWith:),var1);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然，发送消息并不是直接的函数调用，到objc_msgSend里面就是Objective-C Runtime来处理了。&lt;/p&gt;

&lt;h3 id="objc_objectobjc_classojbc_method"&gt;objc&lt;em&gt;object, objc&lt;/em&gt;class 以及 Ojbc_method&lt;/h3&gt;

&lt;p&gt;在Objective-C中，本质上，类、对象和方法都是一个C的结构体&lt;/p&gt;

&lt;p&gt;比如我们知道&lt;code&gt;id&lt;/code&gt;就是指向一个Objective-C的对象的指针，也就是&lt;code&gt;objc_object&lt;/code&gt;的实例，其中有一个&lt;code&gt;isa&lt;/code&gt;指针，这个&lt;code&gt;isa&lt;/code&gt;指向它所属的类。来看看它的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_object {  
    Class isa;
} *id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以当你拿到一个&lt;code&gt;id&lt;/code&gt;指针之后，就可以获取这个对象的类，并且可以检测其是否响应一个&lt;code&gt;selector&lt;/code&gt;。isa指向的&lt;code&gt;objc_class&lt;/code&gt;实例的里面其实保存的就是该对象对应的类的信息。定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_class *Class;  
struct objc_class {  
    Class isa;  
    Class super_class;  
    const char *name;  
    long instance_size;  
    struct objc_ivar_list *ivars;  
    struct objc_method_list **methodLists;  
    struct objc_cache *cache;  
    struct objc_protocol_list *protocols;  
};

struct objc_method_list {  
    struct objc_method_list *obsolete;
    int method_count;
    struct objc_method method_list[1];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这些类的信息包括，继承关系，实现的协议，方法列表，和属性列表，实例大小，ivar的类型和布局等等。其中方法都对应结构体是&lt;code&gt;objc_method&lt;/code&gt;，这个结构体其实就是一个key/value对，定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_selector  *SEL;  
typedef id (*IMP)(id self,SEL _cmd,...);  
struct objc_method {  
    SEL method_name;  
    char *method_types;  
    IMP method_imp;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key是所谓的&lt;code&gt;Selector&lt;/code&gt;(相当于编译器生成的唯一的标识函数的字符串)；而值就是&lt;code&gt;IMP&lt;/code&gt;，一个&lt;code&gt;IMP&lt;/code&gt;就是一个函数指针，由编译器生成的，当你发起一个消息之后，最终它会执行的那个代码，就是由这个函数指针指定的。&lt;/p&gt;

&lt;p&gt;从这些定义中可以看出， 发送一条消息，也就是&lt;code&gt;objc_msgSend&lt;/code&gt;，大概到底做了什么事情。  &lt;/p&gt;

&lt;p&gt;举&lt;code&gt;objc_msgSend(obj, foo)&lt;/code&gt;这个例子来说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，通过 obj 的 isa 指针找到它的 class &lt;/li&gt;
&lt;li&gt;在 class 的 method list 找 foo &lt;/li&gt;
&lt;li&gt;如果 class 中没到 foo，继续往它的 superclass 中找 &lt;/li&gt;
&lt;li&gt;一旦找到 foo 这个函数，就去执行它的实现IMP &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;block&lt;/code&gt;的设计也类似，它也包含了isa的指针&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Block_literal_1 {  
    void *isa; // initialized to &amp;amp;_NSConcreteStackBlock or &amp;amp;_NSConcreteGlobalBlock
    ...
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以block像object一样也是可以响应消息的。&lt;/p&gt;

&lt;h3 id="metaclass"&gt;MetaClass&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;isa&lt;/code&gt;指向对象就是该object对应的类。也就是Objective-C的类本身也是一个对象，暂时我们称之为类对象(class object)。 它包含的信息包括，继承关系，实现的协议，方法列表，和属性列表，实例大小，ivar的类型和布局等等。当你进行类方法(class method)的调用的时候的时候，比方说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[NSObject alloc];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你事实上是把这个消息发给了这个类对象(class object)。&lt;/p&gt;

&lt;p&gt;既然class object是一个实例，那么它必然是属于某一个类，这个类被称作metaclass。一个metaclass就是class object的描述，就像一个class是它的object的描述一样。&lt;/p&gt;

&lt;p&gt;值得一提的是，metaclass的方法列表就是我们称之为class methods的东西：class本身应该响应的那些selectors。当你发送一个消息给class，也就是metaclass的实例的时候，objc_msgSend()会查找metaclass的方法列表（包括它的父类），来决定是否可以响应。一个class method记录在metaclass里，就像instance method记录在class中。&lt;/p&gt;

&lt;p&gt;metaclass也是一个实例，也有父类，也有&lt;code&gt;isa&lt;/code&gt;和&lt;code&gt;super_class&lt;/code&gt;。最终的源头是一个特殊的root class。不过metaclass的&lt;code&gt;isa&lt;/code&gt;指针其实是无关紧要的，因为现实中，没有人会给metaclass object发送消息的。 &lt;br&gt;
相对更重要的是metaclass的继承关系，metaclass有着和class一样的平行的继承关系。所以class methods也就相应的有了继承关系。 &lt;br&gt;
此外，由于root metaclass的父类是root class，所以每一个class object可以响应root class的instance methods &lt;br&gt;
最后任何一个class object都是root class（或者它的子类的）实例  &lt;/p&gt;

&lt;p&gt;下面这张图能很好的总结上面的结论，始终要记住的是，当一个message发送给一个object的时候，这个object首先根据&lt;code&gt;isa&lt;/code&gt;指针来寻找是否可以响应，然后在根据&lt;code&gt;super_class&lt;/code&gt;指针在继承链中寻找&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-11-20.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="appleclasses"&gt;为啥我们要继承 Apple Classes&lt;/h3&gt;

&lt;p&gt;初学Cocoa开发的时候，多数教程都要我们继承一个类比方NSObject，然后我们就开始Coding了。比方说：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyObject *object = [[MyObject alloc] init];  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个语句用来初始化一个实例，类似于 C++ 的 new 关键字。这个语句首先会执行MyObject这个类的+alloc方法，所以继承 Apple 的类我们不仅是获得了很多很好用的属性，而且也继承了这种内存分配的方法。&lt;/p&gt;

&lt;h3 id="classcacheobjc_cachecache"&gt;什么是Class Cache(objc_cache *cache)&lt;/h3&gt;

&lt;p&gt;每次发送一个消息的时候，都要去查找方法列表的实现有个问题，效率低。比如一个class往往只有20%的函数会被经常调用，可能占总调用次数的80%。每个消息都需要遍历一次&lt;code&gt;objc_method_list&lt;/code&gt;并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是&lt;code&gt;objc_class&lt;/code&gt;中另一个重要成员&lt;code&gt;objc_cache&lt;/code&gt;做的事情 - 再找到foo之后，把foo的&lt;code&gt;method_name&lt;/code&gt;作为key，&lt;code&gt;method_imp&lt;/code&gt;作为value给存起来。当再次收到foo消息的时候，可以直接在cache里找到，避免去遍历&lt;code&gt;objc_method_list&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="objc_msgsend"&gt;说回 objc_msgSend 这个方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[self printMessageWithString:@"Hello World!"];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被编译器翻译成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objc_msgSend(self,@selector(printMessageWithString:),@"Hello World!");  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;objc_msgSend执行的步骤大致是这样：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检测这个selector是不是要忽略的。比如Mac OS X开发，有了垃圾回收就不理会retain,release这些消息了&lt;/li&gt;
&lt;li&gt;检测这个target是不是&lt;code&gt;nil&lt;/code&gt;。ObjC的特性是允许对一个&lt;code&gt;nil&lt;/code&gt;对象执行任何一个方法不会Crash，因为会被忽略掉&lt;/li&gt;
&lt;li&gt;如果上面两个都过了，那就开始查找这个类的IMP，先从cache里面找，找得到的话，就跳到对应的函数去执行&lt;/li&gt;
&lt;li&gt;如果cache找不到就到成员方法列表里去找，还找不到，就到父类里去找&lt;/li&gt;
&lt;li&gt;最后还找不到的话，就要进行消息转发逻辑&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=""&gt;消息转发机制&lt;/h3&gt;

&lt;p&gt;在上面的例子中，如果@selector(printMessageWithString:)最终没有找到，通常情况下，程序会在运行时挂掉并抛出&lt;code&gt;unrecognized selector sent to …&lt;/code&gt;的异常。但在异常抛出前，Objective-C的运行时会给你三次拯救程序的机会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Method resolution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fast forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Normal forwarding&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="methodresolution"&gt;Method Resolution&lt;/h3&gt;

&lt;p&gt;在找不到消息对应的函数后，首先，Objective-C运行时会调用+resolveInstanceMethod: 或者+resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。以foo为例，你可以这么实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void fooMethod(id obj, SEL _cmd)  
{
    NSLog(@"Doing foo");
}

+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{
    if(aSEL == @selector(foo:)){
        class_addMethod([self class], aSEL, (IMP)fooMethod, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Core Data有用到这个方法。NSManagedObjects中properties的getter和setter就是在运行时动态添加的&lt;/p&gt;

&lt;p&gt;如果resolve方法返回NO，运行时就会移到下一步：消息转发（Message Forwarding）&lt;/p&gt;

&lt;p&gt;PS：iOS 4.3 加入很多新的 runtime 方法，主要都是以 imp 为前缀的方法，比如 imp_implementationWithBlock() 用 block 快速创建一个 imp 。 &lt;br&gt;
上面的例子可以重写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMP fooIMP = imp_implementationWithBlock(^(id _self) {  
    NSLog(@"Doing foo");
});

class_addMethod([self class], aSEL, fooIMP, "v@:");  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="fastforwarding"&gt;Fast forwarding&lt;/h3&gt;

&lt;p&gt;消息转发（Message Forwarding）首先会执行Fast forwarding，也就是如果目标对象实现了&lt;code&gt;-forwardingTargetForSelector:&lt;/code&gt;，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if(aSelector == @selector(foo:)){
        return alternateObject;
    }
    return [super forwardingTargetForSelector:aSelector];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。&lt;/p&gt;

&lt;p&gt;这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个 NSInvocation 对象，所以相对更快点。&lt;/p&gt;

&lt;h3 id="normalforwarding"&gt;Normal forwarding&lt;/h3&gt;

&lt;p&gt;这一步是Runtime最后一次给你挽救的机会。首先它会发送&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;消息获得函数的参数和返回值类型。如果&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;返回nil，Runtime则会发出&lt;code&gt;-doesNotRecognizeSelector:&lt;/code&gt;消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个&lt;code&gt;NSInvocation&lt;/code&gt;对象并发送&lt;code&gt;-forwardInvocation:&lt;/code&gt;消息给目标对象。&lt;/p&gt;

&lt;p&gt;NSInvocation 实际上就是对一个消息的描述，包括selector 以及参数等信息。所以你可以在&lt;code&gt;-forwardInvocation:&lt;/code&gt;里修改传进来的&lt;code&gt;NSInvocation&lt;/code&gt;对象，然后发送&lt;code&gt;-invokeWithTarget:&lt;/code&gt;消息给它，传进去一个新的目标：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)invocation
{
    SEL sel = invocation.selector;

    if([alternateObject respondsToSelector:sel]) {
        [invocation invokeWithTarget:alternateObject];
    } 
    else {
        [self doesNotRecognizeSelector:sel];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cocoa 里很多地方都利用到了消息传递机制来对语言进行扩展，如 Proxies、NSUndoManager 跟 Responder Chain。NSProxy 就是专门用来作为代理转发消息的；NSUndoManager 截取一个消息之后再发送；而 Responder Chain 保证一个消息转发给合适的响应者。&lt;/p&gt;

&lt;p&gt;Apple 设计这种机制的原因之一就是——用来模拟多重继承（ObjC 原生是不支持多重继承的）。或者把复杂设计隐藏起来。&lt;/p&gt;

&lt;h4 id=""&gt;参考资料&lt;/h4&gt;

&lt;p&gt;&lt;a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html"&gt;Understanding the Objective-C Runtime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://tech.glowing.com/cn/objective-c-runtime/"&gt;Objective-C Runtime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html"&gt;Classes and metaclasses&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>JNI基础介绍</title><description>这里简单介绍一下JNI的语法
&lt;!--more--&gt;

&lt;h4 id=""&gt;初识第一面&lt;/h4&gt;

&lt;h5 id="hellojnijava"&gt;HelloJNI.java&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public class HelloJNI {  
   static {
      System.loadLibrary("hello"); // Load native library at runtime
                                   // hello.dll (Windows) or libhello.so (Unixes)
   }

   // Declare a native method sayHello() that receives nothing and returns void
   private native void sayHello();

   // Test Driver
   public static void main(String[] args) {
      new HelloJNI().sayHello();  // invoke&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/jniji-chu-jie-shao/</link><guid isPermaLink="false">960a4dff-371e-4d2d-885a-5cccd3b27dff</guid><category>Android</category><category>JNI</category><category>Knowledge</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:45:56 GMT</pubDate><content:encoded>这里简单介绍一下JNI的语法
&lt;!--more--&gt;

&lt;h4 id=""&gt;初识第一面&lt;/h4&gt;

&lt;h5 id="hellojnijava"&gt;HelloJNI.java&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public class HelloJNI {  
   static {
      System.loadLibrary("hello"); // Load native library at runtime
                                   // hello.dll (Windows) or libhello.so (Unixes)
   }

   // Declare a native method sayHello() that receives nothing and returns void
   private native void sayHello();

   // Test Driver
   public static void main(String[] args) {
      new HelloJNI().sayHello();  // invoke the native method
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="hellojnihc"&gt;HelloJNI.h/.c&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {  
   printf("Hello World!\n");
   return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数命名约定 &lt;code&gt;Java_{package_and_classname}_{function_name}(JNI arguments)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JNIEnv*: 对于JNI环境的引用, 通过这个入口可以进行jni函数&lt;/li&gt;
&lt;li&gt;jobject: 对于this对象的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="jni"&gt;JNI基础&lt;/h4&gt;

&lt;p&gt;JNI在native系统中定义了下面这些JNI数据类型，来对应Java的类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java基本类型：jint，jbyte，jshort，jlong，jfloat，jdouble，jchar，jboolean对应Java的int，byte，short，long，float，double，char，boolean&lt;/li&gt;
&lt;li&gt;Java应用类型：jobject对应java.lang.Object。同时还有一下子类型
&lt;ul&gt;&lt;li&gt;jclass -&gt; java.lang.Class&lt;/li&gt;
&lt;li&gt;jstring -&gt; java.lang.String&lt;/li&gt;
&lt;li&gt;jthrowable -&gt; java.lang.Throwable&lt;/li&gt;
&lt;li&gt;jarray -&gt; Java Array。也就是jintArray, jbyteArray, jshortArray, jlongArray, jfloatArray, jdoubleArray, jcharArray, jbooleanArray, jobjectArray.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于native的函数都是接受JNI类型参数，返回JNI类型参数，所以一般情况下我们需要这样做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把JNI的参数转换或者拷贝成C可以操作的类型，如jintArray到int[]&lt;/li&gt;
&lt;li&gt;使用C类型参数完成计算&lt;/li&gt;
&lt;li&gt;把结果转换或者拷贝成JNI类型并返回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JNI环境提供了大量的这些转换工作的工具可以帮助大家完成&lt;/p&gt;

&lt;h4 id="javanativie"&gt;在Java和Nativie之间传递参数&lt;/h4&gt;

&lt;h5 id=""&gt;基础类型&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    // In "win\jni_mh.h" - machine header which is machine dependent
    typedef long            jint;
    typedef __int64         jlong;
    typedef signed char     jbyte;

    // In "jni.h"
    typedef unsigned char   jboolean;
    typedef unsigned short  jchar;
    typedef short           jshort;
    typedef float           jfloat;
    typedef double          jdouble;
    typedef jint            jsize;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="string"&gt;String&lt;/h5&gt;

&lt;p&gt;JNI环境提供了函数可以进行很方便的转换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jstring -&gt; char* : &lt;code&gt;const char* GetStringUTFChars(JNIEnv*, jstring, jboolean*)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;char* -&gt; jstring : &lt;code&gt;jstring NewStringUTF(JNIEnv*, char*)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT jstring JNICALL Java_TestJNIString_sayHello(JNIEnv *env, jobject thisObj, jstring inJNIStr) {  
   // Step 1: Convert the JNI String (jstring) into C-String (char*)
   const char *inCStr = (*env)-&amp;gt;GetStringUTFChars(env, inJNIStr, NULL);
   if (NULL == inCSt) return NULL;

   // Step 2: Perform its intended operations
   printf("In C, the received string is: %s\n", inCStr);
   (*env)-&amp;gt;ReleaseStringUTFChars(env, inJNIStr, inCStr);  // release resources

   // Prompt user for a C-string
   char outCStr[128];
   printf("Enter a String: ");
   scanf("%s", outCStr);    // not more than 127 characters

   // Step 3: Convert the C-string (char*) into JNI String (jstring) and return
   return (*env)-&amp;gt;NewStringUTF(env, outCStr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="primitive"&gt;primitive数组&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;jintArray -&gt; jint[], &lt;code&gt;jint* GetIntArrayElements(JNIEnv *env, jintArray a, jboolean *iscopy)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;jint[] -&gt; jintArray, 首先分配内存&lt;code&gt;jintArray NewIntArray(JNIEnv *env, jsize len)&lt;/code&gt;, 然后填充&lt;code&gt;void SetIntArrayRegion(JNIEnv *env, jintArray a, jsize start, jsize len, const jint *buf)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT jdoubleArray JNICALL Java_TestJNIPrimitiveArray_sumAndAverage  
          (JNIEnv *env, jobject thisObj, jintArray inJNIArray) {
   // Step 1: Convert the incoming JNI jintarray to C's jint[]
   jint *inCArray = (*env)-&amp;gt;GetIntArrayElements(env, inJNIArray, NULL);
   if (NULL == inCArray) return NULL;
   jsize length = (*env)-&amp;gt;GetArrayLength(env, inJNIArray);

   // Step 2: Perform its intended operations
   jint sum = 0;
   int i;
   for (i = 0; i &amp;lt; length; i++) {
      sum += inCArray[i];
   }
   jdouble average = (jdouble)sum / length;
   (*env)-&amp;gt;ReleaseIntArrayElements(env, inJNIArray, inCArray, 0); // release resources

   jdouble outCArray[] = {sum, average};

   // Step 3: Convert the C's Native jdouble[] to JNI jdoublearray, and return
   jdoubleArray outJNIArray = (*env)-&amp;gt;NewDoubleArray(env, 2);  // allocate
   if (NULL == outJNIArray) return NULL;
   (*env)-&amp;gt;SetDoubleArrayRegion(env, outJNIArray, 0 , 2, outCArray);  // copy
   return outJNIArray;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="java"&gt;访问对象变量并且调用Java方法&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;访问实例对象&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetObjectID&lt;/li&gt;
&lt;li&gt;GetFieldID&lt;/li&gt;
&lt;li&gt;GetInt&lt;/li&gt;
&lt;li&gt;SetFieldID&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT void JNICALL Java_TestJNIInstanceVariable_modifyInstanceVariable  
          (JNIEnv *env, jobject thisObj) {
   // Get a reference to this object's class
   jclass thisClass = (*env)-&amp;gt;GetObjectClass(env, thisObj);

   // int
   // Get the Field ID of the instance variables "number"
   jfieldID fidNumber = (*env)-&amp;gt;GetFieldID(env, thisClass, "number", "I");
   if (NULL == fidNumber) return;

   // Get the int given the Field ID
   jint number = (*env)-&amp;gt;GetIntField(env, thisObj, fidNumber);
   printf("In C, the int is %d\n", number);

   // Change the variable
   number = 99;
   (*env)-&amp;gt;SetIntField(env, thisObj, fidNumber, number);

   // Get the Field ID of the instance variables "message"
   jfieldID fidMessage = (*env)-&amp;gt;GetFieldID(env, thisClass, "message", "Ljava/lang/String;");
   if (NULL == fidMessage) return;

   // String
   // Get the object given the Field ID
   jstring message = (*env)-&amp;gt;GetObjectField(env, thisObj, fidMessage);

   // Create a C-string with the JNI String
   const char *cStr = (*env)-&amp;gt;GetStringUTFChars(env, message, NULL);
   if (NULL == cStr) return;

   printf("In C, the string is %s\n", cStr);
   (*env)-&amp;gt;ReleaseStringUTFChars(env, message, cStr);

   // Create a new C-string and assign to the JNI string
   message = (*env)-&amp;gt;NewStringUTF(env, "Hello from C");
   if (NULL == message) return;

   // modify the instance variables
   (*env)-&amp;gt;SetObjectField(env, thisObj, fidMessage, message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;访问静态变量&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetStaticFieldID&lt;/li&gt;
&lt;li&gt;GetStatic&lt;type&gt;Field&lt;/type&gt;&lt;/li&gt;
&lt;li&gt;SetStatic&lt;type&gt;Field&lt;/type&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT void JNICALL Java_TestJNIStaticVariable_modifyStaticVariable  
          (JNIEnv *env, jobject thisObj) {
   // Get a reference to this object's class
   jclass cls = (*env)-&amp;gt;GetObjectClass(env, thisObj);

   // Read the int static variable and modify its value
   jfieldID fidNumber = (*env)-&amp;gt;GetStaticFieldID(env, cls, "number", "D");
   if (NULL == fidNumber) return;
   jdouble number = (*env)-&amp;gt;GetStaticDoubleField(env, cls, fidNumber);
   printf("In C, the double is %f\n", number);
   number = 77.88;
   (*env)-&amp;gt;SetStaticDoubleField(env, cls, fidNumber, number);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;访问方法和静态方法&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GetMethodID&lt;/li&gt;
&lt;li&gt;Call&lt;type&gt;Method&lt;/type&gt;&lt;/li&gt;
&lt;li&gt;GetStaticMethodID&lt;/li&gt;
&lt;li&gt;CallStatic&lt;type&gt;Method&lt;/type&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT void JNICALL Java_TestJNICallBackMethod_nativeMethod  
          (JNIEnv *env, jobject thisObj) {

   // Get a class reference for this object
   jclass thisClass = (*env)-&amp;gt;GetObjectClass(env, thisObj);

   // Get the Method ID for method "callback", which takes no arg and return void
   jmethodID midCallBack = (*env)-&amp;gt;GetMethodID(env, thisClass, "callback", "()V");
   if (NULL == midCallBack) return;
   printf("In C, call back Java's callback()\n");
   // Call back the method (which returns void), baed on the Method ID
   (*env)-&amp;gt;CallVoidMethod(env, thisObj, midCallBack);

   jmethodID midCallBackStr = (*env)-&amp;gt;GetMethodID(env, thisClass,
                               "callback", "(Ljava/lang/String;)V");
   if (NULL == midCallBackStr) return;
   printf("In C, call back Java's called(String)\n");
   jstring message = (*env)-&amp;gt;NewStringUTF(env, "Hello from C");
   (*env)-&amp;gt;CallVoidMethod(env, thisObj, midCallBackStr, message);

   jmethodID midCallBackAverage = (*env)-&amp;gt;GetMethodID(env, thisClass,
                                  "callbackAverage", "(II)D");
   if (NULL == midCallBackAverage) return;
   jdouble average = (*env)-&amp;gt;CallDoubleMethod(env, thisObj, midCallBackAverage, 2, 3);
   printf("In C, the average is %f\n", average);

   jmethodID midCallBackStatic = (*env)-&amp;gt;GetStaticMethodID(env, thisClass,
                                 "callbackStatic", "()Ljava/lang/String;");
   if (NULL == midCallBackStatic) return;
   jstring resultJNIStr = (*env)-&amp;gt;CallStaticObjectMethod(env, thisClass, midCallBackStatic);
   const char *resultCStr = (*env)-&amp;gt;GetStringUTFChars(env, resultJNIStr, NULL);
   if (NULL == resultCStr) return;
   printf("In C, the returned string is %s\n", resultCStr);
   (*env)-&amp;gt;ReleaseStringUTFChars(env, resultJNIStr, resultCStr);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="java"&gt;创建java对象和对象数组&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;创建java对象&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FindClass&lt;/li&gt;
&lt;li&gt;NewObject&lt;/li&gt;
&lt;li&gt;AllocObject&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT jobject JNICALL Java_TestJNIConstructor_getIntegerObject  
          (JNIEnv *env, jobject thisObj, jint number) {
   // Get a class reference for java.lang.Integer
   jclass cls = (*env)-&amp;gt;FindClass(env, "java/lang/Integer");

   // Get the Method ID of the constructor which takes an int
   jmethodID midInit = (*env)-&amp;gt;GetMethodID(env, cls, "&amp;lt;init&amp;gt;", "(I)V");
   if (NULL == midInit) return NULL;
   // Call back constructor to allocate a new instance, with an int argument
   jobject newObj = (*env)-&amp;gt;NewObject(env, cls, midInit, number);

   // Try runnning the toString() on this newly create object
   jmethodID midToString = (*env)-&amp;gt;GetMethodID(env, cls, "toString", "()Ljava/lang/String;");
   if (NULL == midToString) return NULL;
   jstring resultStr = (*env)-&amp;gt;CallObjectMethod(env, newObj, midToString);
   const char *resultCStr = (*env)-&amp;gt;GetStringUTFChars(env, resultStr, NULL);
   printf("In C: the number is %s\n", resultCStr);

   return newObj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;创建java数组&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NewObjectArray&lt;/li&gt;
&lt;li&gt;GetObjectArrayElement&lt;/li&gt;
&lt;li&gt;setObjectArrayElement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;JNIEXPORT jobjectArray JNICALL Java_TestJNIObjectArray_sumAndAverage  
          (JNIEnv *env, jobject thisObj, jobjectArray inJNIArray) {
   // Get a class reference for java.lang.Integer
   jclass classInteger = (*env)-&amp;gt;FindClass(env, "java/lang/Integer");
   // Use Integer.intValue() to retrieve the int
   jmethodID midIntValue = (*env)-&amp;gt;GetMethodID(env, classInteger, "intValue", "()I");
   if (NULL == midIntValue) return NULL;

   // Get the value of each Integer object in the array
   jsize length = (*env)-&amp;gt;GetArrayLength(env, inJNIArray);
   jint sum = 0;
   int i;
   for (i = 0; i &amp;lt; length; i++) {
      jobject objInteger = (*env)-&amp;gt;GetObjectArrayElement(env, inJNIArray, i);
      if (NULL == objInteger) return NULL;
      jint value = (*env)-&amp;gt;CallIntMethod(env, objInteger, midIntValue);
      sum += value;
   }
   double average = (double)sum / length;
   printf("In C, the sum is %d\n", sum);
   printf("In C, the average is %f\n", average);

   // Get a class reference for java.lang.Double
   jclass classDouble = (*env)-&amp;gt;FindClass(env, "java/lang/Double");

   // Allocate a jobjectArray of 2 java.lang.Double
   jobjectArray outJNIArray = (*env)-&amp;gt;NewObjectArray(env, 2, classDouble, NULL);

   // Construct 2 Double objects by calling the constructor
   jmethodID midDoubleInit = (*env)-&amp;gt;GetMethodID(env, classDouble, "&amp;lt;init&amp;gt;", "(D)V");
   if (NULL == midDoubleInit) return NULL;
   jobject objSum = (*env)-&amp;gt;NewObject(env, classDouble, midDoubleInit, (double)sum);
   jobject objAve = (*env)-&amp;gt;NewObject(env, classDouble, midDoubleInit, average);
   // Set to the jobjectArray
   (*env)-&amp;gt;SetObjectArrayElement(env, outJNIArray, 0, objSum);
   (*env)-&amp;gt;SetObjectArrayElement(env, outJNIArray, 1, objAve);

   return outJNIArray;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=""&gt;本地和全局变量&lt;/h5&gt;

&lt;p&gt;任何类似FindClass(), GetMethodID(), GetFieldID()返回的引用是一个本地引用。&lt;/p&gt;

&lt;p&gt;想要使用全局引用的话，需要使用&lt;code&gt;NewGlobalRef()&lt;/code&gt;，&lt;code&gt;DeleteGlobalRef()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Global Reference to the Java class "java.lang.Integer"
static jclass classInteger;  
static jmethodID midIntegerInit;

jobject getInteger(JNIEnv *env, jobject thisObj, jint number) {

   // Get a class reference for java.lang.Integer if missing
   if (NULL == classInteger) {
      printf("Find java.lang.Integer\n");
      jclass classIntegerLocal = (*env)-&amp;gt;FindClass(env, "java/lang/Integer");
      // Create a global reference from the local reference
      classInteger = (*env)-&amp;gt;NewGlobalRef(env, classIntegerLocal);
      // No longer need the local reference, free it!
      //(*env)-&amp;gt;DeleteLocalRef(env, classIntegerLocal);
   }

   if (NULL == classInteger) return NULL;

   // Get the Method ID of the Integer's constructor if missing
   if (NULL == midIntegerInit) {
      printf("Get Method ID for java.lang.Integer's constructor\n");
      midIntegerInit = (*env)-&amp;gt;GetMethodID(env, classInteger, "&amp;lt;init&amp;gt;", "(I)V");
   }
   if (NULL == midIntegerInit) return NULL;

   // Call back constructor to allocate a new instance, with an int argument
   jobject newObj = (*env)-&amp;gt;NewObject(env, classInteger, midIntegerInit, number);
   printf("In C, constructed java.lang.Integer with number %d\n", number);
   return newObj;
}

JNIEXPORT jobject JNICALL Java_TestJNIReference_getIntegerObject  
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}

JNIEXPORT jobject JNICALL Java_TestJNIReference_anotherGetIntegerObject  
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>Fresco 简介</title><description>&lt;p&gt;翻译自&lt;a href="https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/"&gt;Introducing Fresco: A new image library for Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里并不是单纯的翻译，只是试图总结一下fresco的特点&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;fresco是facebook开源的管理图片的库，主要还是为了管理里图片使用的内存&lt;/p&gt;

&lt;h4 id=""&gt;不同的内存区域&lt;/h4&gt;

&lt;p&gt;对于Android来说，可以使用的内存区域包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ashmem&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ashmem&lt;/code&gt;非常像&lt;code&gt;native heap&lt;/code&gt;，但是有趣的是，它可以&lt;code&gt;pin/unpin&lt;/code&gt;。所谓的&lt;code&gt;unpin&lt;/code&gt;其实就是lazy free。也就是说，仅仅当Android需要更多内存的时候，才会释放这块内存。当Android重新&lt;code&gt;pin&lt;/code&gt;这块内存时，如果这块内存不曾被是放过的话，那么原来的数据还在那里。&lt;/p&gt;

&lt;h4 id="purgeablebitmaps"&gt;Purgeable bitmaps&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ashmem&lt;/code&gt;并不能被java应用直接访问，除了一些特殊情况，恰好，图片就是其中的一个。当你创建一个解码过的图片，&lt;code&gt;bitmap&lt;/code&gt;&lt;/p&gt;</description><link>http://localhost:2368/fresco-jian-jie/</link><guid isPermaLink="false">dc622685-8779-4629-a300-3659e90220d3</guid><category>Android</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:41:21 GMT</pubDate><content:encoded>&lt;p&gt;翻译自&lt;a href="https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/"&gt;Introducing Fresco: A new image library for Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里并不是单纯的翻译，只是试图总结一下fresco的特点&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;fresco是facebook开源的管理图片的库，主要还是为了管理里图片使用的内存&lt;/p&gt;

&lt;h4 id=""&gt;不同的内存区域&lt;/h4&gt;

&lt;p&gt;对于Android来说，可以使用的内存区域包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native heap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ashmem&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ashmem&lt;/code&gt;非常像&lt;code&gt;native heap&lt;/code&gt;，但是有趣的是，它可以&lt;code&gt;pin/unpin&lt;/code&gt;。所谓的&lt;code&gt;unpin&lt;/code&gt;其实就是lazy free。也就是说，仅仅当Android需要更多内存的时候，才会释放这块内存。当Android重新&lt;code&gt;pin&lt;/code&gt;这块内存时，如果这块内存不曾被是放过的话，那么原来的数据还在那里。&lt;/p&gt;

&lt;h4 id="purgeablebitmaps"&gt;Purgeable bitmaps&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ashmem&lt;/code&gt;并不能被java应用直接访问，除了一些特殊情况，恰好，图片就是其中的一个。当你创建一个解码过的图片，&lt;code&gt;bitmap&lt;/code&gt;，api允许你指定这个图片是&lt;code&gt;purgeable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BitmapFactory.Options = new BitmapFactory.Options();  
options.inPurgeable = true;  
Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Purgeable的bitmap就在ashmem里。然而，garbage collector并不自动回收这些内存。Android系统只是在渲染系统渲染的时候&lt;code&gt;pin&lt;/code&gt;住这些内存，然后在渲染结束后&lt;code&gt;unpin&lt;/code&gt;他们。如果这些&lt;code&gt;unpined&lt;/code&gt;图片需要再次被渲染的话，Android就会重新取得需要的内容，如果有必要的话，会重新在线(on the fly)解码。&lt;/p&gt;

&lt;p&gt;但是在线解码(on the fly decode)发生在主线程里，由于这个原因，Google并不建议使用这个特性。目前的建议是使用&lt;code&gt;inBitmap&lt;/code&gt;。但是这个新标志只有在android3.0里才存在。此外在4.4之前，这个特性还有个限制，是要求新解压的图片和原来的图片的大小要一致。这个要求显然并不适合大多数场景。&lt;/p&gt;

&lt;h4 id=""&gt;鱼和熊掌可以兼得&lt;/h4&gt;

&lt;p&gt;我们发现了一个既可以不用频繁释放／分配内存，又可以不阻塞UI的办法。也就是说，如果我们事先在非UI线程pin好一块内存，然后只要永远不要unpin它，这样我们就在ashmem上得到了一块内存，但是却不会引起UI阻塞的问题。非常幸运，我们NDK中有一个函数就是干这个的，&lt;code&gt;AdnroidBitmap_lockPixels&lt;/code&gt;。这个函数设计之初是用来和&lt;code&gt;unlockPixels&lt;/code&gt;配合使用来unpin这块内存的。当我们故意调用lockPixels但是并不调用unlockPixels时候，我们就很安全的在Java Heap之外得到了一块并不阻塞UI线程的内存。&lt;/p&gt;

&lt;h4 id="c"&gt;像C++一样思考&lt;/h4&gt;

&lt;p&gt;ashmem没有类似garbage collector来保证不会内存泄漏。所以我们需要自己来保证。&lt;/p&gt;

&lt;p&gt;在C++里，通常的解决办法是使用smart pointer类来实现引用计数。但这使用了cpp语言的工具，copy constructor，assignment constructor，deterministic destructor。这些语法糖在java中并不存在。所以我们自己要实现类似的机制。&lt;/p&gt;

&lt;p&gt;我们通过两个类来实现这个机制。一个叫做&lt;code&gt;SharedReference&lt;/code&gt;。这个类有两个方法，一个是&lt;code&gt;addReference&lt;/code&gt;，一个是&lt;code&gt;deleteReferece&lt;/code&gt;。通过这个来实现引用计数。&lt;/p&gt;

&lt;p&gt;当然这个对于java程序员来说，明显很容易出错。java语言设计的时候就是要避免这样做。所以在&lt;code&gt;SharedReference&lt;/code&gt;顶上，我们设计了&lt;code&gt;CloseableReference&lt;/code&gt;。它是现实了&lt;code&gt;Closeable&lt;/code&gt;接口，并且也实现了&lt;code&gt;cloneabel&lt;/code&gt;。在构造函数和&lt;code&gt;clone()&lt;/code&gt;里我们调用&lt;code&gt;addReferece()&lt;/code&gt;。在&lt;code&gt;close()&lt;/code&gt;里，我们调用&lt;code&gt;deleteReference()&lt;/code&gt;。所以java开发者只需要遵循两个原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给一个CloseableReference赋值时候，调&lt;code&gt;.clone()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;离开作用域时，调用&lt;code&gt;.close()&lt;/code&gt;，通常是在一个final块里。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="loaderpipeline"&gt;它不仅仅是一个loader，更是一个pipeline&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/fresco_imagepipeline.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;在移动设备上显示一张图片要涉及很多步骤，如果我们把这些步骤看作是&lt;code&gt;pipeline&lt;/code&gt;而不是&lt;code&gt;loader&lt;/code&gt;，那么事情会完全不一样。每一步都应该尽可能的独立于其他步骤，每一步获得一些参数的输入，而产出一些结果。一些可能需要可以并行，一些需要串行。有一些仅仅需要在一些特定条件下执行，有一些对执行他们的线程有特定要求。而且考虑到弱网络和大图片，我们希望用户可以尽可能快的看到图片，即使是图片并没有完全下载下来。&lt;/p&gt;

&lt;p&gt;对于Java来说，一般异步代码同步的时候我们会用到&lt;code&gt;Future&lt;/code&gt;。但Future只能在执行完毕的时候带回来一个结果。当我们处理大图片的时候，我们需要处理一系列的结果。&lt;/p&gt;

&lt;p&gt;我们的解决办法是涉及一个泛化版的Future，&lt;code&gt;DataSource&lt;/code&gt;。它提供一个订阅的方法，调用者必须传递一个&lt;code&gt;DataSubscriber&lt;/code&gt;和&lt;code&gt;Executor&lt;/code&gt;给它。DataSubscriber将会收到DataSource发来的中间结果或者是最终结果的通知，并且会提供一个简单的办法去区分这两者。&lt;/p&gt;

&lt;p&gt;在底层，上图里的每一个盒子都是使用一个新的架构实现的，叫做Producer/Consumer。这个架构是学习&lt;code&gt;ReactiveX&lt;/code&gt;架构而搭建的。整个接口非常简洁，&lt;code&gt;Producer&lt;/code&gt;只有一个方法，&lt;code&gt;produceResults&lt;/code&gt;，它只有一个参数是&lt;code&gt;Consumer&lt;/code&gt;对象。相对应的，&lt;code&gt;Consumer&lt;/code&gt;只有一个方法叫做&lt;code&gt;onNewResult&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们使用一个向下面这样的一个系统来使producters变成一个链条。假设我们有一个producer，它的工作就是把类型I变成类型O。看起来如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class OutputProducer&amp;lt;I, O&amp;gt; implements Producer&amp;lt;O&amp;gt; {

  private final Producer&amp;lt;I&amp;gt; mInputProducer;

  public OutputProducer(Producer&amp;lt;I&amp;gt; inputProducer) {
    this.mInputProducer = inputProducer;
  }

  public void produceResults(Consumer&amp;lt;O&amp;gt; outputConsumer, ProducerContext context) {
    Consumer&amp;lt;I&amp;gt; inputConsumer = new InputConsumer(outputConsumer);
    mInputProducer.produceResults(inputConsumer, context);
  }

  private static class InputConsumer implements Consumer&amp;lt;I&amp;gt; {
    private final Consumer&amp;lt;O&amp;gt; mOutputConsumer;

    public InputConsumer(Consumer&amp;lt;O&amp;gt; outputConsumer) {
      mOutputConsumer = outputConsumer;
    }

    public void onNewResult(I newResult, boolean isLast) {
      O output = doActualWork(newResult);
      mOutputConsumer.onNewResult(output, isLast);      
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个设计使得我们可以组建一个非常复杂的工作步骤链条，但是却能保证每一步逻辑上的独立性。&lt;/p&gt;

&lt;h4 id=""&gt;动画－－从一到多&lt;/h4&gt;

&lt;p&gt;表情一般来说是GIF或者WebP格式的，这带来了挑战，一个动画由许多bitmap组成，每一个都需要解码，存储和显示。对于大的动画来说，在内存中存储每一帧显然是不可能的。&lt;/p&gt;

&lt;p&gt;所以我们设计了&lt;code&gt;AnimatedDrawable&lt;/code&gt;，实现了Android的&lt;code&gt;Animatable&lt;/code&gt;接口，可以支持以上两种格式，并且我们做了优化，如果比较小，我们可以把所有帧放在内存中，否则我们在线解码。不过这些都是高度可定制的&lt;/p&gt;

&lt;h4 id="drawee"&gt;关于Drawee&lt;/h4&gt;

&lt;p&gt;我们以前的实现使用了View，当图片下载好之后把一个placeholder的View和交换，但是这样效率不高，因为换View会引起Android重新计算整个layout pass。所以一个更合理的做法是使用Android的Drawable，它可以实时交换而不引起任何其他代价。&lt;/p&gt;

&lt;p&gt;所以我们引入了&lt;code&gt;Drawee&lt;/code&gt;。这个MVC类似的架构用来显示图片。Modal叫做&lt;code&gt;DraweeHierarchy&lt;/code&gt;，它由有层次的Drawable组成，每一个实现特定的功能，imaging，layering，fade-in，scaling等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DraweeControllers&lt;/code&gt;连接image pipeline和处理image后台的操作。它从pipeline收到通知，然后决定怎么处理结果。它决定了DrawHierarchy实际显示了什么，不论是placeholder，错误，或者准备好的图片。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DraweeViews&lt;/code&gt;仅仅有非常有限的功能，但是它提供的功能却是决定性的。它接受Android系统的事件来发出信号说，这个view是不是还在屏幕上显示。当不在屏幕上的时候，DraweeView可以让DraweeController释放被图片使用资源。同时如果这个图片还没有下载的话，它可以取消，这样就可以节约网络带宽的使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;完&lt;/code&gt;&lt;/p&gt;</content:encoded></item><item><title>新Android Gradle Build Tools: Gradle 2.5</title><description>&lt;p&gt;Android Studio 1.3已经除了稳定版了。新特性包括了完全NDK支持，而且一个主要的更改是DSL(Domain-Specific Language)的变化。&lt;/p&gt;

&lt;p&gt;翻译自&lt;a href="http://inthecheesefactory.com/blog/new-gradle-build-tools-with-gradle-2.5/en"&gt;inthechessefactory&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id="androidgradlebuildtools"&gt;什么是Android Gradle Build Tools&lt;/h4&gt;

&lt;p&gt;在把每个module的build.gradle文件传递给Gradle之前，Android Gradle Build Tools 用来提前处理下这些文件。&lt;/p&gt;

&lt;p&gt;Gradle Build Tools的版本是在project的build.gradle里指定的，类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    classpath 'com.android.tools.build:gradle:1.2.3'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gradle Build Tools版本和Gradle版本对应关系如下：&lt;/p&gt;

&lt;table style="width: 100%; border: 1px solid black;" border="1px solid black"&gt;  
&lt;tbody&gt;  
&lt;tr&gt;  
&lt;td style="width: 50%; border: 1px solid black; padding: 10px; text-align: center;"&gt;&lt;strong&gt;Android Gradle Plugin&lt;/strong&gt;&lt;/td&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;&lt;strong&gt;Gradle&lt;/strong&gt;&lt;/td&gt;  
&lt;/tr&gt;  
&lt;tr&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;1.0.0 - 1.1.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description><link>http://localhost:2368/xin-android-gradle-build-tools-gradle-2-5/</link><guid isPermaLink="false">be583e8d-8591-4bde-9cb1-1c7d12ebad69</guid><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:32:29 GMT</pubDate><content:encoded>&lt;p&gt;Android Studio 1.3已经除了稳定版了。新特性包括了完全NDK支持，而且一个主要的更改是DSL(Domain-Specific Language)的变化。&lt;/p&gt;

&lt;p&gt;翻译自&lt;a href="http://inthecheesefactory.com/blog/new-gradle-build-tools-with-gradle-2.5/en"&gt;inthechessefactory&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id="androidgradlebuildtools"&gt;什么是Android Gradle Build Tools&lt;/h4&gt;

&lt;p&gt;在把每个module的build.gradle文件传递给Gradle之前，Android Gradle Build Tools 用来提前处理下这些文件。&lt;/p&gt;

&lt;p&gt;Gradle Build Tools的版本是在project的build.gradle里指定的，类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    classpath 'com.android.tools.build:gradle:1.2.3'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gradle Build Tools版本和Gradle版本对应关系如下：&lt;/p&gt;

&lt;table style="width: 100%; border: 1px solid black;" border="1px solid black"&gt;  
&lt;tbody&gt;  
&lt;tr&gt;  
&lt;td style="width: 50%; border: 1px solid black; padding: 10px; text-align: center;"&gt;&lt;strong&gt;Android Gradle Plugin&lt;/strong&gt;&lt;/td&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;&lt;strong&gt;Gradle&lt;/strong&gt;&lt;/td&gt;  
&lt;/tr&gt;  
&lt;tr&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;1.0.0 - 1.1.3&lt;/td&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;2.2.1 - 2.3&lt;/td&gt;  
&lt;/tr&gt;  
&lt;tr&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;1.2+&lt;/td&gt;  
&lt;td style="border: 1px solid black; text-align: center;"&gt;2.2.1+&lt;/td&gt;  
&lt;/tr&gt;  
&lt;/tbody&gt;  
&lt;/table&gt;

&lt;h4 id="thenewandroidgradlebuildtools"&gt;The new Android Gradle Build Tools&lt;/h4&gt;

&lt;p&gt;使用新的Gradle Build Tools的话，只需要换掉build tools的version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    classpath 'com.android.tools.build:gradle-experimental:0.1.0'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过只有gradle2.5才能匹配使用，所以需要设置gradle-wrapper.properties&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-bin.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后像下面这样编辑模块的build.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: 'com.android.model.application'

model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = "23.0.0 rc3"

        defaultConfig.with {
            applicationId = "com.inthecheesefactory.hellojni25"
            minSdkVersion.apiLevel = 15
            targetSdkVersion.apiLevel = 22
            versionCode = 1
            versionName = "1.0"
        }
    }

    android.buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles += file('proguard-rules.pro')
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细看就会发现，plugin不再是&lt;code&gt;com.android.application&lt;/code&gt;，而是&lt;code&gt;com.android.model.application&lt;/code&gt;。 &lt;br&gt;
&lt;code&gt;+=&lt;/code&gt;被引入表示在一个collection中增加一些元素。&lt;/p&gt;

&lt;h4 id="ndk"&gt;支持 NDK&lt;/h4&gt;

&lt;p&gt;修改项目的local.properites文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ndk.dir=PATH_TO_NDK_ROOT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;，或者直接使用android studio下载ndk&lt;/p&gt;

&lt;p&gt;然后在java的package里创建&lt;code&gt;HelloJni.java&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HelloJni {  
    public native String stringFromJNI();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在src/main目录下创建jni文件夹，然后创建hello-jni.c文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;string.h&amp;gt;
#include &amp;lt;jni.h&amp;gt;

jstring  
Java_com_inthecheesefactory_hellojni25_HelloJni_stringFromJNI( JNIEnv* env,  
                                                  jobject thiz )
{
#if defined(__arm__)
  #if defined(__ARM_ARCH_7A__)
    #if defined(__ARM_NEON__)
      #if defined(__ARM_PCS_VFP)
        #define ABI "armeabi-v7a/NEON (hard-float)"
      #else
        #define ABI "armeabi-v7a/NEON"
      #endif
    #else
      #if defined(__ARM_PCS_VFP)
        #define ABI "armeabi-v7a (hard-float)"
      #else
        #define ABI "armeabi-v7a"
      #endif
    #endif
  #else
   #define ABI "armeabi"
  #endif
#elif defined(__i386__)
   #define ABI "x86"
#elif defined(__x86_64__)
   #define ABI "x86_64"
#elif defined(__mips64)  /* mips64el-* toolchain defines __mips__ too */
   #define ABI "mips64"
#elif defined(__mips__)
   #define ABI "mips"
#elif defined(__aarch64__)
   #define ABI "arm64-v8a"
#else
   #define ABI "unknown"
#endif

    return (*env)-&amp;gt;NewStringUTF(env, "Hello from JNI !!  Compiled with ABI " ABI ".");
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请记住让&lt;code&gt;com_inthecheesefactory_hellojni25&lt;/code&gt;和HelloJni.java的包名是一致的。makefile不再需要了。&lt;/p&gt;

&lt;p&gt;现在在&lt;code&gt;MainActivity.java&lt;/code&gt;里测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {  
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Toast.makeText(MainActivity.this,
                    new HelloJni().stringFromJNI(),
                    Toast.LENGTH_LONG).show();
    } 
    ...

    static {
        System.loadLibrary("hello-jni");
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=SeKXi-viRrk"&gt;more video&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>到底能不能在extension里override一个函数?</title><description>&lt;p&gt;Swift教程中明确说了，extension并不能override一个已有的函数！可是最近发现有人extension UIImageView时，可以&lt;code&gt;override layoutSubviews()&lt;/code&gt;，到底什么鬼？？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;在&lt;a href="http://stackoverflow.com/questions/27109006/can-you-override-between-extensions-in-swift-or-not-compiler-seems-confused"&gt;stackoverflow&lt;/a&gt;上找到了答案，并且自己也确认过了。&lt;/p&gt;

&lt;p&gt;解释是这样的：&lt;/p&gt;

&lt;p&gt;至少在目前版本（swift1.1， 1.2），只要在如下两种情况下就可以override函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;涉及到的类都是从NSObject继承来的,不使用inout修饰符并且没有enum&lt;/li&gt;
&lt;li&gt;或者使用了@objc修饰符的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心思想是，只有&lt;em&gt;Objective-C compatible&lt;/em&gt;的方法和属性才能在extension里override&lt;/p&gt;

&lt;p&gt;请参考下面的例子&lt;/p&gt;

&lt;h4 id="1"&gt;例子1&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class A : NSObject { }  
class B : A { }

class SubNSObject : NSObject {}  
class NotSubbed {}  
enum SomeEnum { case c1, c2; }

extension A  
{
    var y&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/dao-di-neng-bu-neng-zai-extensionli-override-ge-han-shu/</link><guid isPermaLink="false">353c0072-2bd4-4c46-9957-25fd7075c641</guid><category>Swift</category><category>iOS</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:30:38 GMT</pubDate><content:encoded>&lt;p&gt;Swift教程中明确说了，extension并不能override一个已有的函数！可是最近发现有人extension UIImageView时，可以&lt;code&gt;override layoutSubviews()&lt;/code&gt;，到底什么鬼？？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;在&lt;a href="http://stackoverflow.com/questions/27109006/can-you-override-between-extensions-in-swift-or-not-compiler-seems-confused"&gt;stackoverflow&lt;/a&gt;上找到了答案，并且自己也确认过了。&lt;/p&gt;

&lt;p&gt;解释是这样的：&lt;/p&gt;

&lt;p&gt;至少在目前版本（swift1.1， 1.2），只要在如下两种情况下就可以override函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;涉及到的类都是从NSObject继承来的,不使用inout修饰符并且没有enum&lt;/li&gt;
&lt;li&gt;或者使用了@objc修饰符的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心思想是，只有&lt;em&gt;Objective-C compatible&lt;/em&gt;的方法和属性才能在extension里override&lt;/p&gt;

&lt;p&gt;请参考下面的例子&lt;/p&gt;

&lt;h4 id="1"&gt;例子1&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class A : NSObject { }  
class B : A { }

class SubNSObject : NSObject {}  
class NotSubbed {}  
enum SomeEnum { case c1, c2; }

extension A  
{
    var y : String { get { return "YinA"; } }
    func f() -&amp;gt; A { return A(); }
    func g(val: SubNSObject, test: Bool = false) { }

    func h(val: NotSubbed, test: Bool = false) { }
    func j(val: SomeEnum) { }
    func k(val: SubNSObject, inout test: Bool) { }
}

extension B  
{
    // THESE OVERIDES DO COMPILE:
    override var  y : String { get { return "YinB"; } }
    override func f() -&amp;gt; A { return A(); }
    override func g(val: SubNSObject, test: Bool) { }

    // THESE OVERIDES DO NOT COMPILE:
    //override func h(val: NotSubbed, test: Bool = false) { }
    //override func j(val: SomeEnum) { }
    //override func k(val: SubNSObject, inout test: Bool) { }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="2"&gt;例子2&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class A { }

class B : A { }

extension A  
{
    @objc var y : String { get { return "YinA" } }
}

extension B  
{
   @objc override var y : String { get { return "YinB" } }
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>建立universal framework</title><description>&lt;p&gt;xcode很有意思，当选择平台是iOS device时，framework支持的architecture是arm系列的，然而如果是iOS simulator的话，又仅产生支持x86_64系列的architecture。&lt;/p&gt;

&lt;p&gt;那么当我们如何编译framework时使它可以支持所有architecture呢&lt;/p&gt;

&lt;p&gt;&lt;a href="https://medium.com/@syshen/create-an-ios-universal-framework-148eb130a46c"&gt;参考资料1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://kodmunki.wordpress.com/2015/03/04/cocoa-touch-frameworks-for-ios8-remix/"&gt;参考资料2&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;要点如下：&lt;/p&gt;

&lt;p&gt;在build phases里增加一个脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;######################
# Options
######################

REVEAL_ARCHIVE_IN_FINDER=false

FRAMEWORK_NAME="${PROJECT_NAME}"

SIMULATOR_LIBRARY_PATH="${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${FRAMEWORK_NAME}.framework"

DEVICE_LIBRARY_PATH="${BUILD_DIR}/${CONFIGURATION}-iphoneos/${FRAMEWORK_NAME}.framework"

UNIVERSAL_LIBRARY_DIR="${BUILD_DIR}/${CONFIGURATION}&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/jian-li-universal-framework/</link><guid isPermaLink="false">bf8b97b4-4a34-445e-af61-0e50c6699251</guid><category>iOS</category><category>Xcode</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:29:03 GMT</pubDate><content:encoded>&lt;p&gt;xcode很有意思，当选择平台是iOS device时，framework支持的architecture是arm系列的，然而如果是iOS simulator的话，又仅产生支持x86_64系列的architecture。&lt;/p&gt;

&lt;p&gt;那么当我们如何编译framework时使它可以支持所有architecture呢&lt;/p&gt;

&lt;p&gt;&lt;a href="https://medium.com/@syshen/create-an-ios-universal-framework-148eb130a46c"&gt;参考资料1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://kodmunki.wordpress.com/2015/03/04/cocoa-touch-frameworks-for-ios8-remix/"&gt;参考资料2&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;要点如下：&lt;/p&gt;

&lt;p&gt;在build phases里增加一个脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;######################
# Options
######################

REVEAL_ARCHIVE_IN_FINDER=false

FRAMEWORK_NAME="${PROJECT_NAME}"

SIMULATOR_LIBRARY_PATH="${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${FRAMEWORK_NAME}.framework"

DEVICE_LIBRARY_PATH="${BUILD_DIR}/${CONFIGURATION}-iphoneos/${FRAMEWORK_NAME}.framework"

UNIVERSAL_LIBRARY_DIR="${BUILD_DIR}/${CONFIGURATION}-iphoneuniversal"

FRAMEWORK="${UNIVERSAL_LIBRARY_DIR}/${FRAMEWORK_NAME}.framework"


######################
# Build Frameworks
######################

xcodebuild -workspace ${PROJECT_NAME}.xcworkspace -scheme ${PROJECT_NAME} -sdk iphonesimulator -configuration ${CONFIGURATION} clean build CONFIGURATION_BUILD_DIR=${BUILD_DIR}/${CONFIGURATION}-iphonesimulator 2&amp;gt;&amp;amp;1

xcodebuild -workspace ${PROJECT_NAME}.xcworkspace -scheme ${PROJECT_NAME} -sdk iphoneos -configuration ${CONFIGURATION} clean build CONFIGURATION_BUILD_DIR=${BUILD_DIR}/${CONFIGURATION}-iphoneos 2&amp;gt;&amp;amp;1

######################
# Create directory for universal
######################

rm -rf "${UNIVERSAL_LIBRARY_DIR}"

mkdir "${UNIVERSAL_LIBRARY_DIR}"

mkdir "${FRAMEWORK}"


######################
# Copy files Framework
######################

cp -r "${DEVICE_LIBRARY_PATH}/." "${FRAMEWORK}"


######################
# Make an universal binary
######################

lipo "${SIMULATOR_LIBRARY_PATH}/${FRAMEWORK_NAME}" "${DEVICE_LIBRARY_PATH}/${FRAMEWORK_NAME}" -create -output "${FRAMEWORK}/${FRAMEWORK_NAME}" | echo

# For Swift framework, Swiftmodule needs to be copied in the universal framework
if [ -d "${SIMULATOR_LIBRARY_PATH}/Modules/${FRAMEWORK_NAME}.swiftmodule/" ]; then
    cp -f ${SIMULATOR_LIBRARY_PATH}/Modules/${FRAMEWORK_NAME}.swiftmodule/* "${FRAMEWORK}/Modules/${FRAMEWORK_NAME}.swiftmodule/" | echo
fi

if [ -d "${DEVICE_LIBRARY_PATH}/Modules/${FRAMEWORK_NAME}.swiftmodule/" ]; then
    cp -f ${DEVICE_LIBRARY_PATH}/Modules/${FRAMEWORK_NAME}.swiftmodule/* "${FRAMEWORK}/Modules/${FRAMEWORK_NAME}.swiftmodule/" | echo
fi

######################
# On Release, copy the result to release directory
######################

OUTPUT_DIR="${PROJECT_DIR}/Output/${FRAMEWORK_NAME}-${CONFIGURATION}-iphoneuniversal/"

rm -rf "$OUTPUT_DIR"
mkdir -p "$OUTPUT_DIR"

cp -r "${FRAMEWORK}" "$OUTPUT_DIR"

if [ ${REVEAL_ARCHIVE_IN_FINDER} = true ]; then
    open "${OUTPUT_DIR}/"
fi
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>自定义Container View Controllers</title><description>&lt;p&gt;多数情况下，container view controller 就像普通的view controller。它管理着view，内容，与其他对象协同工作，并且响应在repsonder chain里的事件。&lt;/p&gt;

&lt;p&gt;当你设计一个container的时候，你需要显式的在你的container，和它的子controller之间创建父子关系。如下图。注意，&lt;code&gt;不仅仅controller之间需要显式的指定关系，view之间的关系也需要显式的指定&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-07-14_1.png" alt=""&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id="container"&gt;常见的Container设计的例子&lt;/h3&gt;

&lt;h4 id="navigationcontrollerviewcontroller"&gt;Navigation Controller管理着一些由子View Controller组成的栈&lt;/h4&gt;

&lt;p&gt;如图所示，Navigation Controller管理着一系列不同的子ViewController。在这个栈最上面的ViewController的View会被显示出来。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-07-14_2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Navigation Controller定义了一些行为  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;topViewController -- 目前显示的vc&lt;/li&gt;
&lt;li&gt;viewControllers -- 所有子vc&lt;/li&gt;
&lt;li&gt;pushViewController:animated: -- 显示&lt;/li&gt;
&lt;li&gt;popViewControllerAnimated: -- 弹出&lt;/li&gt;
&lt;li&gt;delegate -- 可以让使用者当状态改变的时候收到通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Navigation Controller 使用子VC的一些属性来改变当前显示的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;navigationItem -- 提供了navigation&lt;/li&gt;&lt;/ul&gt;</description><link>http://localhost:2368/zi-ding-yi-container-view-controllers/</link><guid isPermaLink="false">e88fe815-be12-40d2-9ce1-1b980e1fc859</guid><category>Objc</category><category>iOS</category><category>Skill</category><dc:creator>Alchemist Li</dc:creator><pubDate>Wed, 25 Nov 2015 03:27:00 GMT</pubDate><content:encoded>&lt;p&gt;多数情况下，container view controller 就像普通的view controller。它管理着view，内容，与其他对象协同工作，并且响应在repsonder chain里的事件。&lt;/p&gt;

&lt;p&gt;当你设计一个container的时候，你需要显式的在你的container，和它的子controller之间创建父子关系。如下图。注意，&lt;code&gt;不仅仅controller之间需要显式的指定关系，view之间的关系也需要显式的指定&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-07-14_1.png" alt=""&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id="container"&gt;常见的Container设计的例子&lt;/h3&gt;

&lt;h4 id="navigationcontrollerviewcontroller"&gt;Navigation Controller管理着一些由子View Controller组成的栈&lt;/h4&gt;

&lt;p&gt;如图所示，Navigation Controller管理着一系列不同的子ViewController。在这个栈最上面的ViewController的View会被显示出来。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-07-14_2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Navigation Controller定义了一些行为  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;topViewController -- 目前显示的vc&lt;/li&gt;
&lt;li&gt;viewControllers -- 所有子vc&lt;/li&gt;
&lt;li&gt;pushViewController:animated: -- 显示&lt;/li&gt;
&lt;li&gt;popViewControllerAnimated: -- 弹出&lt;/li&gt;
&lt;li&gt;delegate -- 可以让使用者当状态改变的时候收到通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Navigation Controller 使用子VC的一些属性来改变当前显示的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;navigationItem -- 提供了navigation toolbar的内容&lt;/li&gt;
&lt;li&gt;toolbarItem -- 提供了底部bar的内容&lt;/li&gt;
&lt;li&gt;editButtonItem -- 提供了可以从navigation item访问子view的途径，这样就可以改变子view的edit mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="tabbarcontrollervc"&gt;Tab Bar Controller使用一个子VC的集合&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/11/2015-07-14_3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Tab Bar Controller定义了一些行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;viewControllers -- 所有子vc&lt;/li&gt;
&lt;li&gt;selectedViewController -- 设置或读取哪个子vc&lt;/li&gt;
&lt;li&gt;delegate -- 可以让使用者当状态改变的时候收到通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tab Bar Controller 使用子VC的一些属性来改变当前显示的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tabBarItem -- 提供了底部bar的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="pagecontrollerdatasourcevc"&gt;Page Controller使用DataSource去显示新的子VC&lt;/h4&gt;

&lt;p&gt;Page Controller支持无限多的页面显示，所以把所有的page都放在内存中是不可能的。相反，page controller在需要的时候拉取需要的page。这样page controller就使用一个pull model而不是让app把所有的page一下子push到里面&lt;/p&gt;

&lt;p&gt;Page Controller定义了一些行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spineLocation -- 定义page是如何组织的，有时候只显示一个page，有时候需要两个&lt;/li&gt;
&lt;li&gt;transitionStyle -- 定义了过场动画的风格&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="containercontroller"&gt;实现自定义Container Controller&lt;/h4&gt;

&lt;h5 id="vc"&gt;增加和移除子vc&lt;/h5&gt;

&lt;p&gt;始终应该记住的是，在&lt;code&gt;addSubview&lt;/code&gt;&lt;em&gt;之前&lt;/em&gt;&lt;code&gt;addChildViewController&lt;/code&gt;,在&lt;code&gt;removeFromSuperVieww&lt;/code&gt;&lt;em&gt;之后&lt;/em&gt;&lt;code&gt;removeFromParentViewController&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外，设置子view的大小最好也在addSubview之前&lt;/p&gt;

&lt;p&gt;增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) displayContentController: (UIViewController*) content;
{
    [self addChildViewController:content];                 
    content.view.frame = [self frameForContentController]; 
    [self.view addSubview:self.currentClientView];
    [content didMoveToParentViewController:self];          
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addChildViewController&lt;/code&gt;会自动调用&lt;code&gt;willMoveToPa&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void) hideContentController: (UIViewController*) content
{
    [content willMoveToParentViewController:nil];  
    [content.view removeFromSuperview];            
    [content removeFromParentViewController];      
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=""&gt;简单的转场动画&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;- (void) cycleFromViewController: (UIViewController*) oldC
        toViewController: (UIViewController*) newC
{
    [oldC willMoveToParentViewController:nil];                        
    [self addChildViewController:newC];

    newC.view.frame = [self newViewStartFrame];                       
    CGRect endFrame = [self oldViewEndFrame];

    [self transitionFromViewController: oldC toViewController: newC   
          duration: 0.25 options:0
          animations:^{
             newC.view.frame = oldC.view.frame;                       
             oldC.view.frame = endFrame;
          }
          completion:^(BOOL finished) {
             [oldC removeFromParentViewController];                   
             [newC didMoveToParentViewController:self];
          }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="callback"&gt;自定义显示和旋转的Callback行为&lt;/h5&gt;

&lt;p&gt;多数时候不用管这个事情，但是有时候你希望自己控制消息发送的时机之类的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL) shouldAutomaticallyForwardAppearanceMethods
{
    return NO;
}

-(void) viewWillAppear:(BOOL)animated
{
    [self.child beginAppearanceTransition: YES animated: animated];
}

-(void) viewDidAppear:(BOOL)animated
{
    [self.child endAppearanceTransition];
}

-(void) viewWillDisappear:(BOOL)animated
{
    [self.child beginAppearanceTransition: NO animated: animated];
}

-(void) viewDidDisappear:(BOOL)animated
{
    [self.child endAppearanceTransition];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;旋转与显示类似，首先要重载&lt;code&gt;shouldAutomaticallyForwardRotationMethods&lt;/code&gt;，然后在合适的地方调用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;willRotateToInterfaceOrientation:duration:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willAnimateRotationToInterfaceOrientation:duration:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;didRotateFromInterfaceOrientation:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id="bestpractices"&gt;Best practices&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;不要干这事！！因为毕竟实现一个复杂的container不是一件容易的事情&lt;/li&gt;
&lt;li&gt;只访问子VC的最顶层的那个View，其他View不要碰！&lt;/li&gt;
&lt;li&gt;如果需要子VC暴露一些接口，可以使用protocol！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@protocol MyContentContainerProtocol &amp;lt;NSObject&amp;gt;
    ...
@end
- (void) displayContentController: (UIViewController&amp;lt;MyContentContainerProtocol&amp;gt;*) content;
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item></channel></rss>